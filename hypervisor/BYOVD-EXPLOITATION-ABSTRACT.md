# BYOVD Kernel Driver Exploitation Chain
## Abstract Concepts and Replication Guide

**Document Version:** 1.0
**Last Updated:** December 25, 2025
**Classification:** Research Documentation
**Author:** Project Ombra Team

---

## Executive Summary

This document describes a technique for gaining Ring 0 (kernel mode) code execution on Windows 10/11 systems using two legitimately signed kernel drivers. The approach requires no exploit of software vulnerabilities in the traditional sense—instead, it leverages *intended functionality* exposed by drivers designed for virtualization and hardware tuning.

The core insight: certain signed drivers expose powerful primitives (memory allocation, physical memory access, code loading) that, when chained together, provide arbitrary kernel code execution while maintaining valid code signatures and Secure Boot compatibility.

---

## Table of Contents

1. [Fundamental Concepts](#1-fundamental-concepts)
2. [The Two-Driver Architecture](#2-the-two-driver-architecture)
3. [Driver 1: The Virtualization Driver (Primary Target)](#3-driver-1-the-virtualization-driver-primary-target)
4. [Driver 2: The Hardware Utility Driver (Bypass Mechanism)](#4-driver-2-the-hardware-utility-driver-bypass-mechanism)
5. [Reverse Engineering Methodology](#5-reverse-engineering-methodology)
6. [The Authentication Protocol](#6-the-authentication-protocol)
7. [The -618 Validation Bypass](#7-the--618-validation-bypass)
8. [Complete Attack Chain](#8-complete-attack-chain)
9. [Detection Surface and Cleanup](#9-detection-surface-and-cleanup)
10. [Key Learnings and Pitfalls](#10-key-learnings-and-pitfalls)

---

## 1. Fundamental Concepts

### 1.1 What is BYOVD?

**Bring Your Own Vulnerable Driver (BYOVD)** is an attack technique where:

1. The attacker provides a legitimately signed kernel driver
2. The driver exposes powerful primitives (memory access, code execution)
3. These primitives are *intended functionality*, not bugs
4. The signature remains valid, so Windows loads the driver
5. The attacker uses the driver's features to execute arbitrary kernel code

This bypasses:
- Code Integrity / Driver Signature Enforcement
- Secure Boot (driver has valid certificate chain)
- Kernel Patch Protection (no patches to protected code)

### 1.2 Why Two Drivers?

Our exploitation chain requires two drivers because:

1. **Driver 1** provides the ultimate goal: kernel memory allocation and code loading
2. **Driver 1** has a validation check that fails in certain environments
3. **Driver 2** provides physical memory access to patch Driver 1's validation flags
4. After patching, Driver 2 is unloaded; only Driver 1 remains

Think of it as: Driver 2 unlocks the door, Driver 1 is what we walk through.

### 1.3 Ring Levels Explained

| Ring | Name | What Runs Here | Our Access |
|------|------|----------------|------------|
| 3 | User Mode | Applications, our loader | Starting point |
| 0 | Kernel Mode | Windows kernel, drivers | Goal |
| -1 | Hypervisor | Hyper-V, VMM | Ultimate goal |

Normal applications cannot access Ring 0. Signed drivers can. By loading a signed driver and using its primitives, we bridge from Ring 3 to Ring 0.

---

## 2. The Two-Driver Architecture

### 2.1 Driver Selection Criteria

We needed drivers that:
- Are legitimately signed by trusted certificate authorities
- Are NOT on Microsoft's driver blocklist
- Expose powerful primitives to usermode callers
- Have predictable behavior across Windows versions

### 2.2 What We Found

| Role | Driver | Origin | Primitive Provided |
|------|--------|--------|-------------------|
| Primary | VirtualBox fork | Android emulator | Kernel memory alloc + code load |
| Bypass | CPU tuning utility | Hardware vendor | Physical memory read/write |

The primary driver is a modified VirtualBox support driver from a popular Android emulator. The bypass driver is an Intel CPU undervolting utility.

### 2.3 Why These Specific Drivers?

**Primary Driver:**
- Designed to load VirtualBox kernel modules
- Exposes IOCTL interface for: allocate kernel memory, copy code, execute
- Has session-based authentication (not just "open and use")
- Modified by vendor, introducing additional validation check

**Bypass Driver:**
- Uses MmMapIoSpace to map physical memory
- Simple IOCTL interface: address in, data out (or reverse)
- No authentication required beyond driver handle
- Actively used by legitimate users (not suspicious)

---

## 3. Driver 1: The Virtualization Driver (Primary Target)

### 3.1 Driver Overview

- **Original Source:** VirtualBox 7.x kernel support driver
- **Modifications:** Vendor added custom function and validation checks
- **File Size:** ~376 KB (x86-64)
- **Certificate:** Valid DigiCert Extended Validation
- **Blocklist Status:** NOT blocked (as of December 2025)

### 3.2 Device Interface

The driver creates kernel device objects. To communicate:

1. Open device handle using NT native API (not Win32 CreateFile)
2. Device path uses NT namespace, not DOS namespace
3. Requires Administrator privileges

**Key Insight:** Standard Win32 `CreateFile("\\.\DriverName")` fails because no DOS symlink exists. Must use `NtCreateFile` with the NT device path.

### 3.3 The IOCTL Interface

The driver exposes ~41 IOCTL commands. The ones we care about:

| Command | Purpose | Complexity |
|---------|---------|------------|
| COOKIE | Establish authenticated session | Required first |
| LDR_OPEN | Allocate executable kernel memory | Core primitive |
| LDR_LOAD | Copy code + call entry point | Core primitive |
| PAGE_ALLOC_EX | Allocate dual-mapped memory | Alternative path |
| MSR_PROBER | Read/write CPU MSR registers | DISABLED in this build |

### 3.4 The Loading Sequence

```
┌─────────────────────────────────────────────────────┐
│ 1. COOKIE - Authenticate with driver                │
│    → Provide magic string and version               │
│    → Receive session cookies for future calls       │
├─────────────────────────────────────────────────────┤
│ 2. LDR_OPEN - Request kernel memory                 │
│    → Specify size needed                            │
│    → Driver allocates EXECUTABLE kernel pool        │
│    → Returns kernel address to usermode             │
├─────────────────────────────────────────────────────┤
│ 3. LDR_LOAD - Load and execute code                 │
│    → Provide code buffer + size + entry point       │
│    → Driver copies to allocated address             │
│    → Driver IMMEDIATELY CALLS entry point           │
│    → Your code runs in Ring 0!                      │
└─────────────────────────────────────────────────────┘
```

### 3.5 IOCTL Code Calculation

The driver uses a specific formula to generate IOCTL codes:

```
IOCTL = (DeviceType << 16) | (Access << 14) | ((FuncNum | 0x80) << 2) | Method
```

Where:
- DeviceType = 0x22 (FILE_DEVICE_UNKNOWN)
- Access = 0x02 (FILE_ANY_ACCESS)
- FuncNum = function number (1, 2, 3, ...)
- 0x80 is OR'd with function number (device-specific quirk)
- Method = 0 (METHOD_BUFFERED)

**Critical Discovery:** The vendor inserted an extra function at position 2, shifting all subsequent function numbers by 1 compared to standard VirtualBox.

---

## 4. Driver 2: The Hardware Utility Driver (Bypass Mechanism)

### 4.1 Driver Overview

- **Purpose:** Intel CPU undervolting and power management
- **Certificate:** Valid vendor signature
- **Capability:** Physical memory read/write via MmMapIoSpace
- **Blocklist Status:** NOT blocked (as of December 2025)
- **CVE:** Assigned but not actively exploited in wild

### 4.2 Why Physical Memory Access Matters

Physical memory access lets us:
- Read/write any kernel memory by translating virtual to physical
- Bypass kernel memory protections (they work on virtual addresses)
- Patch data in kernel drivers after they're loaded

### 4.3 IOCTL Interface

Two simple IOCTLs:

| IOCTL | Direction | Input | Output |
|-------|-----------|-------|--------|
| Read | Phys → User | 8-byte physical address | Value (size by buffer) |
| Write | User → Phys | 8-byte address + value | None |

The read IOCTL determines size from output buffer length:
- 1 byte output buffer → read 1 byte
- 2 byte output buffer → read 2 bytes
- 4 byte output buffer → read 4 bytes
- 8 byte output buffer → read 8 bytes

The write IOCTL determines size from input buffer length:
- 9 bytes (8+1) → write 1 byte
- 10 bytes (8+2) → write 2 bytes
- 12 bytes (8+4) → write 4 bytes
- 16 bytes (8+8) → write 8 bytes

### 4.4 Physical Address Translation

To convert a virtual address to physical:

1. **Obtain CR3** - The page table base register
   - Scan physical memory for SYSTEM process structure
   - Read DirectoryTableBase field (offset +0x28 in EPROCESS)

2. **Walk the 4-level page table hierarchy:**
   - PML4 (Page Map Level 4) - indexed by VA bits [47:39]
   - PDPT (Page Directory Pointer Table) - indexed by VA bits [38:30]
   - PD (Page Directory) - indexed by VA bits [29:21]
   - PT (Page Table) - indexed by VA bits [20:12]
   - Page offset from VA bits [11:0]

3. **Handle large pages:**
   - 1GB pages: stop at PDPT level
   - 2MB pages: stop at PD level
   - 4KB pages: full walk to PT

Each table entry contains the physical page frame number of the next level, plus flags indicating present, large page, etc.

---

## 5. Reverse Engineering Methodology

### 5.1 Tools Used

- **IDA Pro / Ghidra** - Static disassembly and decompilation
- **x64dbg** - Dynamic analysis (kernel debugging setup)
- **WinDbg** - Kernel-level debugging
- **API Monitor** - IOCTL traffic capture
- **Hex editor** - Binary constant extraction

### 5.2 Finding the Magic Values

**The Magic String:**

1. Set breakpoint on DeviceIoControl in test harness
2. Trace into driver's IOCTL handler
3. Find string comparison for authentication
4. Extract 16-byte string from binary at referenced offset

**Result:** Found at binary offset 0x36d58, value "The Magic Word!" (including null)

**The Initial Cookie:**

1. Trace COOKIE IOCTL validation logic
2. Find comparison with expected initial value
3. Cookie compared against hardcoded 32-bit value

**Result:** Found at RVA 0x8f2d, value 0x69726F74 (ASCII "tori")

**Standard VirtualBox uses "Bori" (0x69726F42)** - vendor changed this!

### 5.3 Finding Structure Layouts

**Method 1: Size Validation Tracing**

1. Driver validates cbIn/cbOut (input/output buffer sizes)
2. Trace to find exact size comparisons
3. Wrong sizes cause immediate failure with specific error

**Result:** COOKIE requires exactly 48 bytes in, 56 bytes out

**Method 2: Field Access Analysis**

1. After size validation, driver accesses structure fields
2. Each memory access reveals field offset
3. Cross-reference with VirtualBox source for field names

**Example finding:**
```
RVA 0x47bc: mov rax, [rcx+18h]  ; Access field at +0x18
```
This accesses the pSession field in the COOKIE output structure.

### 5.4 Finding the -618 Check

**Symptom:** LDR_OPEN returns error code -618 (VERR_LDR_GENERAL_FAILURE)

**Investigation:**

1. Search binary for 0xFFFFFD96 (-618 as signed 32-bit)
2. Found at RVA 0x1d594
3. Trace backwards to find condition

**Disassembly at RVA 0x1d584:**
```
movzx eax, byte [driver_base + 0x4a1a0]  ; Load flag 1
test al, al                               ; Check if zero
je error_path                             ; If zero, fail
test r11b, r11b                          ; Check flag 2 (in register)
jne success_path                         ; If non-zero, continue
mov esi, 0xFFFFFD96                      ; Set -618 error
```

**Root Cause:** Two global flags must be non-zero:
- Offset 0x4a1a0: ntoskrnl.exe validation result
- Offset 0x4a210: hal.dll validation result

These flags are set during driver initialization when it enumerates kernel modules. The enumeration fails in nested virtualization environments, leaving both at zero.

### 5.5 Understanding the Vendor Modifications

By comparing against stock VirtualBox source:

1. **Inserted QUERY_INFO function** at position 2
   - Shifted all subsequent function numbers by 1
   - Broke compatibility with VBox IOCTL codes

2. **Changed initial cookie** from "Bori" to "tori"
   - Prevents stock VBox clients from connecting

3. **Added kernel module validation**
   - Checks ntoskrnl.exe and hal.dll exist
   - Sets global flags during init
   - LDR_OPEN checks these flags

4. **Disabled MSR_PROBER**
   - Compile-time disabled, returns -12
   - Prevents MSR-based attacks

---

## 6. The Authentication Protocol

### 6.1 Session Establishment (COOKIE Handshake)

The driver uses session-based authentication:

```
┌──────────────────────────────────────────────────────────────┐
│ CLIENT                                   DRIVER              │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  1. Prepare COOKIE request:                                  │
│     - Initial cookie: 0x69726F74 ("tori")                    │
│     - Arbitrary session cookie                               │
│     - Magic string: "The Magic Word!"                        │
│     - Version: 0x320000                                      │
│     - Buffer sizes: 48 in, 56 out                            │
│     - Header flags: 0x42000042                               │
│                                                              │
│  ─────────────────────────────────────────────────────────►  │
│                                                              │
│  2. Driver validates:                                        │
│     - Initial cookie matches expected                        │
│     - Magic string matches exactly                           │
│     - Buffer sizes are exact                                 │
│     - Header flags include magic value                       │
│                                                              │
│  3. Driver generates session:                                │
│     - New 32-bit session cookie                              │
│     - Kernel session pointer                                 │
│     - Records client process                                 │
│                                                              │
│  ◄─────────────────────────────────────────────────────────  │
│                                                              │
│  4. Client receives:                                         │
│     - u32Cookie (new, use for all future calls)              │
│     - u32SessionCookie (echoed back, for validation)         │
│     - pSession (kernel pointer, informational)               │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### 6.2 Authenticated Requests

All subsequent IOCTLs must include:

1. **u32Cookie** - The new cookie from COOKIE response
2. **u32SessionCookie** - The session cookie from COOKIE response
3. **fFlags** - Must include 0x42000042 (magic header flag)
4. **Correct buffer sizes** - Exact match required

If any value is wrong, driver returns error immediately.

### 6.3 Why This Authentication Exists

The driver is designed for VirtualBox internal use:
- Only VirtualBox user-mode components should call it
- Magic string prevents random processes from connecting
- Session cookies prevent cross-process handle theft
- Helps detect debugger attachment (unexpected caller)

For our purposes, we simply replicate the expected protocol.

---

## 7. The -618 Validation Bypass

### 7.1 The Problem

When we call LDR_OPEN (allocate kernel memory), the driver checks two global flags:

```
if (ntoskrnl_flag == 0) return -618;
if (hal_flag == 0) return -618;
```

These flags are set during driver initialization. In nested virtualization:
- Driver's module enumeration code fails
- Flags remain at their default value: 0
- LDR_OPEN always fails with -618

**This is NOT a security check** - it's a sanity check that breaks in unexpected environments.

### 7.2 Why the Flags Fail

During DriverEntry, the driver:
1. Walks PsLoadedModuleList (list of loaded kernel modules)
2. Searches for ntoskrnl.exe and hal.dll
3. Validates their PE headers
4. Sets flags to 1 if validation passes

In nested KVM + Hyper-V:
- Module list appears corrupted or differently structured
- Validation fails for unknown reason (exact cause unclear)
- Both flags stay at 0

### 7.3 The Bypass Strategy

**Key Insight:** These are just bytes in driver memory. If we can write to kernel memory, we can set them to 1 ourselves.

**The Problem:** We can't use Driver 1's memory access (LDR_OPEN is blocked!). We need another path to kernel memory.

**The Solution:** Driver 2 provides physical memory access. We can:
1. Load Driver 2 (hardware utility driver)
2. Find SYSTEM process CR3 (page table root)
3. Calculate physical address of flag locations
4. Write 1 to both flags via physical memory
5. Unload Driver 2
6. Now Driver 1's LDR_OPEN succeeds!

### 7.4 Step-by-Step Bypass Process

```
┌─────────────────────────────────────────────────────────────┐
│ 1. LOAD DRIVER 2                                            │
│    - Create service registry entry                          │
│    - Start service (driver loads into kernel)               │
│    - Open handle to device                                  │
├─────────────────────────────────────────────────────────────┤
│ 2. FIND SYSTEM CR3                                          │
│    - Scan physical memory 0x1a2000 - 0x1b0000               │
│    - Look for EPROCESS structure signature                  │
│    - Validate by checking process name = "System"           │
│    - Read DirectoryTableBase field (+0x28)                  │
├─────────────────────────────────────────────────────────────┤
│ 3. FIND DRIVER 1 BASE ADDRESS                               │
│    - Query SystemModuleInformation via NtQuerySystemInfo    │
│    - Search returned list for driver name                   │
│    - Extract ImageBase value                                │
├─────────────────────────────────────────────────────────────┤
│ 4. TRANSLATE VIRTUAL TO PHYSICAL                            │
│    - For each flag address (base + 0x4a1a0, base + 0x4a210) │
│    - Walk page table using CR3 and physical reads           │
│    - Get physical page frame + page offset                  │
├─────────────────────────────────────────────────────────────┤
│ 5. PATCH THE FLAGS                                          │
│    - Write 1 to ntoskrnl flag physical address              │
│    - Write 1 to hal flag physical address                   │
│    - Total: 2 bytes written                                 │
├─────────────────────────────────────────────────────────────┤
│ 6. CLEANUP DRIVER 2                                         │
│    - Close device handle                                    │
│    - Stop and delete service                                │
│    - Securely delete driver file from disk                  │
├─────────────────────────────────────────────────────────────┤
│ 7. PROCEED WITH DRIVER 1                                    │
│    - LDR_OPEN now succeeds (flags are 1)                    │
│    - Load kernel code normally                              │
└─────────────────────────────────────────────────────────────┘
```

### 7.5 Timing Window

Driver 2 is loaded for approximately 10-15 milliseconds:
- Load: ~5ms
- Find CR3: ~2ms
- Translate + patch: ~3ms
- Unload: ~5ms

This minimizes detection window and forensic evidence.

---

## 8. Complete Attack Chain

### 8.1 Prerequisites

**Required Files:**
- Driver 1 binary (virtualization driver)
- Driver 2 binary (hardware utility driver)
- Loader executable (orchestrates everything)
- Payload (code to run in Ring 0)

**Required Privileges:**
- Administrator (to load drivers)
- SeLoadDriverPrivilege (to call NtLoadDriver)

**System Requirements:**
- Windows 10/11 (x64)
- Neither driver on blocklist
- Secure Boot can be enabled (drivers are signed)

### 8.2 Phase 1: Driver 2 Deployment

1. Extract Driver 2 to temp location
2. Create registry key for driver service
3. Call NtLoadDriver to load into kernel
4. Open device handle for IOCTL communication
5. Record current timestamp for later cleanup

### 8.3 Phase 2: -618 Bypass

1. Scan physical memory to find SYSTEM CR3
2. Query NtQuerySystemInformation for Driver 1 base
3. Translate flag virtual addresses to physical
4. Write 0x01 to both flag locations
5. Verify writes succeeded (read back)

### 8.4 Phase 3: Driver 2 Cleanup

1. Close device handle
2. Unload driver (NtUnloadDriver)
3. Delete registry service key
4. Secure-delete driver file (multiple overwrites)
5. Record cleanup timestamp

### 8.5 Phase 4: Driver 1 Activation

1. Open Driver 1 device handle (NtCreateFile)
2. Perform COOKIE handshake
3. Receive session cookies

### 8.6 Phase 5: Kernel Code Loading

1. Call LDR_OPEN with payload size
2. Receive executable kernel address
3. Prepare payload:
   - Apply relocations for kernel address
   - Set entry point offset
4. Call LDR_LOAD with payload
5. Driver copies and calls entry point
6. **Payload now executing in Ring 0**

### 8.7 Phase 6: Post-Activation Cleanup

Once our code runs in kernel, we can clean up evidence:

1. **Wipe Driver 2 traces:**
   - Clear MmUnloadedDrivers (list of unloaded drivers)
   - Clear PiDDBCacheTable (driver signature cache)
   - Delete prefetch files

2. **Wipe ETW evidence:**
   - Disable ETW-TI (Threat Intelligence) provider
   - Walk ETW circular buffers
   - Zero events in our timestamp window
   - Re-enable ETW-TI

3. **Ongoing stealth:**
   - Driver 1 remains loaded but hidden via EPT
   - No kernel artifacts point to our code
   - Secure Boot still valid

---

## 9. Detection Surface and Cleanup

### 9.1 Evidence Created During Attack

| Evidence Type | When Created | Persistence |
|---------------|--------------|-------------|
| Service registry key | Driver load | Until deleted |
| Driver file on disk | Before load | Until deleted |
| PsLoadedModuleList entry | While loaded | Until unload |
| MmUnloadedDrivers entry | After unload | Until cleared |
| PiDDBCacheTable entry | First load ever | Until cleared |
| ETW events | Throughout | Until buffer rolls/wiped |
| Prefetch files | First execution | Until deleted |

### 9.2 What We Can Clean

**Kernel-mode access required (after payload running):**
- MmUnloadedDrivers - walk list, remove entry
- PiDDBCacheTable - find hash bucket, unlink entry
- ETW buffers - scan circular buffers, zero matching events

**User-mode cleanup:**
- Registry keys - DeleteKey
- Files - secure overwrite + delete
- Prefetch - delete from C:\Windows\Prefetch

### 9.3 What We Cannot Clean

**Potentially transmitted before cleanup:**
- Microsoft telemetry batches (sent periodically)
- Kernel memory dumps (if crash occurs)
- Third-party AV/EDR telemetry

**Mitigating factors:**
- Driver 2 is legitimate software, millions of users
- Loading it for 10ms then unloading is unusual but not definitively malicious
- No payload signature or hash exposed

### 9.4 Detection Resistance

| Detection Method | Status | Notes |
|------------------|--------|-------|
| Driver blocklist | Clean | Neither driver blocked |
| Signature check | Clean | Both have valid signatures |
| Code integrity | Clean | No unsigned code loaded |
| Kernel memory scan | Risk | Payload in pool, but EPT-hidden |
| MmUnloadedDrivers | Clean | Wiped post-activation |
| ETW events | Clean | Wiped post-activation |
| PIDDB cache | Clean | Wiped post-activation |
| Behavioral analysis | Risk | Unusual driver load/unload pattern |

---

## 10. Key Learnings and Pitfalls

### 10.1 Things That Broke Along the Way

**1. Wrong device path format**
- Used Win32 `\\.\DriverName` path
- Driver has no DOS symlink
- Fix: Use NT path `\Device\DriverName` with NtCreateFile

**2. Wrong buffer sizes**
- VirtualBox docs say one size
- This driver enforces different exact sizes
- Fix: Extract exact sizes from binary (cbIn/cbOut checks)

**3. Wrong initial cookie**
- Stock VirtualBox uses "Bori" (0x69726F42)
- This driver changed it to "tori" (0x69726F74)
- Fix: Extract from binary disassembly

**4. Wrong function numbers**
- Assumed standard VBox IOCTL mapping
- Vendor inserted extra function at position 2
- Fix: Recompute all IOCTL codes with shifted numbers

**5. MSR_PROBER disabled**
- Planned to use MSR writes for bypass
- Returns -12 (not supported)
- Fix: Use second driver instead

**6. Race condition on cleanup**
- Deleted driver file before device fully accessible
- Fix: Verify device open before cleanup

### 10.2 Critical Values Reference

| Value | Description | How Found |
|-------|-------------|-----------|
| 0x69726F74 | Initial cookie | Binary disassembly at RVA 0x8f2d |
| "The Magic Word!" | Auth string | Binary offset 0x36d58 |
| 0x320000 | Driver version | Binary RVA 0x4787 |
| 0x42000042 | Header flags | IOCTL handler validation code |
| 0x4a1a0 | ntoskrnl flag | -618 check disassembly |
| 0x4a210 | hal flag | -618 check disassembly |
| 48 / 56 | COOKIE sizes | Size check code |
| 328 / 40 | LDR_OPEN sizes | Size check code |

### 10.3 Replication Checklist

To replicate this research:

1. [ ] Obtain Driver 1 binary (from emulator installation)
2. [ ] Obtain Driver 2 binary (from utility website)
3. [ ] Verify neither is blocklisted (check Microsoft list)
4. [ ] Disassemble Driver 1 to extract:
   - [ ] Magic string and offset
   - [ ] Initial cookie value
   - [ ] Header flags value
   - [ ] Driver version
   - [ ] IOCTL function mapping
   - [ ] Structure sizes (cbIn/cbOut)
   - [ ] Validation flag offsets
5. [ ] Disassemble Driver 2 to extract:
   - [ ] Read/write IOCTL codes
   - [ ] Buffer format (address + value layout)
6. [ ] Implement IOCTL communication:
   - [ ] NtCreateFile for device open
   - [ ] DeviceIoControl with exact buffers
7. [ ] Implement -618 bypass:
   - [ ] CR3 scanner
   - [ ] Page table walker
   - [ ] Physical memory read/write
8. [ ] Implement kernel code loader:
   - [ ] COOKIE handshake
   - [ ] LDR_OPEN memory allocation
   - [ ] LDR_LOAD with entry point
9. [ ] Implement cleanup:
   - [ ] Driver 2 artifact elimination
   - [ ] Kernel trace wiping (post-payload)

### 10.4 What We Never Solved

1. **Why module enumeration fails in nested virt** - exact root cause unknown
2. **Alternative to second driver** - would prefer single-driver solution
3. **Persistent stealth** - kernel traces cleared but memory still resident
4. **Cross-version offsets** - flag offsets may differ in other driver builds

---

## Appendix A: Glossary

| Term | Definition |
|------|------------|
| BYOVD | Bring Your Own Vulnerable Driver |
| IOCTL | I/O Control - kernel driver command interface |
| Ring 0 | Kernel privilege level |
| Ring -1 | Hypervisor privilege level |
| CR3 | Control Register 3 - page table base |
| EPT | Extended Page Tables (Intel nested paging) |
| NPT | Nested Page Tables (AMD nested paging) |
| ETW | Event Tracing for Windows |
| EPROCESS | Windows process kernel structure |
| PML4/PDPT/PD/PT | Page table hierarchy levels |
| VMExit | Trap from guest to hypervisor |
| VMCALL | Explicit call from guest to hypervisor |

---

## Appendix B: Error Codes

| Code | Name | Meaning |
|------|------|---------|
| 0 | VINF_SUCCESS | Operation succeeded |
| -12 | VERR_NOT_SUPPORTED | Feature disabled/unavailable |
| -22 | VERR_INVALID_PARAMETER | Wrong buffer size or value |
| -225 | VERR_INTERNAL_ERROR | Generic failure |
| -618 | VERR_LDR_GENERAL_FAILURE | Module loader validation failed |
| -3100 | VERR_GENERAL_FAILURE | Driver-level failure |

---

## Document History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | Dec 25, 2025 | Initial comprehensive documentation |

---

*This document contains research information for educational purposes. The techniques described leverage intended functionality in legitimately signed software. No software vulnerabilities are exploited in the traditional sense.*
