ZeroHVCI Exploit Framework - File Structure
===========================================

Total Lines of Code: 1683 (excluding this file)

Directory: Ombra-Hypervisor/OmbraLoader/zerohvci/

┌─────────────────────────────────────────────────────────────────┐
│ Core Headers (Namespace: zerohvci)                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ntdefs.h (169 lines)                                           │
│  ├─ NT kernel structure definitions                             │
│  ├─ KTHREAD/EPROCESS offsets                                    │
│  ├─ Function pointer typedefs                                   │
│  └─ Windows version offset constants                            │
│                                                                  │
│  utils.h (506 lines)                                            │
│  ├─ Kernel object leaking (GetKernelObject)                     │
│  ├─ PE parsing (LdrMapImage, LdrProcessRelocs)                  │
│  ├─ Signature matching (MatchSign)                              │
│  ├─ Gadget address leaking                                      │
│  └─ Kernel image utilities                                      │
│                                                                  │
│  exploit.h (196 lines)                                          │
│  ├─ CVE-2024-26229 (CSC exploit)                                │
│  ├─ CVE-2024-35250 (KS exploit)                                 │
│  ├─ EPROCESS/KTHREAD leaking                                    │
│  └─ Kernel R/W primitives                                       │
│                                                                  │
│  kforge.h (382 lines)                                           │
│  ├─ ROP gadget scanning                                         │
│  ├─ Kernel stack manipulation                                   │
│  ├─ Arbitrary kernel function calls                             │
│  └─ Template-based call wrappers                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ Public API                                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  zerohvci.h (30 lines)                                          │
│  └─ Unified public API declarations                             │
│                                                                  │
│  zerohvci.cpp (125 lines)                                       │
│  ├─ Initialize() - Exploit chain orchestration                  │
│  ├─ ReadKernelMemory() - Kernel read wrapper                    │
│  ├─ WriteKernelMemory() - Kernel write wrapper                  │
│  ├─ AllocateKernelPool() - Pool allocation                      │
│  ├─ Cleanup() - Resource cleanup                                │
│  └─ Status query functions                                      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ Hyper-V Runtime Hijacking (Namespace: zerohvci::hyperv)         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  hyperv_hijack.h (750+ lines)                                   │
│  ├─ RuntimeHijacker class                                       │
│  ├─ Hyper-V module detection                                    │
│  ├─ VMExit handler signature scanning                           │
│  │   ├─ Version-specific signature database lookup              │
│  │   └─ Legacy pattern fallback                                 │
│  ├─ Payload injection into hv.exe                               │
│  │   ├─ Trampoline mechanism for >2GB payloads                  │
│  │   └─ Direct patching for nearby payloads                     │
│  ├─ Intel/AMD architecture detection                            │
│  └─ IndirectContext support (builds >= 17763)                   │
│                                                                  │
│  version_detect.h (400+ lines)                                  │
│  ├─ Windows version detection (RtlGetVersion)                   │
│  ├─ KTHREAD offset database                                     │
│  ├─ VMExit signature database (Intel/AMD)                       │
│  ├─ Build-specific call offsets                                 │
│  └─ IndirectContext flag management                             │
│                                                                  │
│  trampoline.h (400+ lines)                                      │
│  ├─ Trampoline shellcode generation                             │
│  │   └─ mov rax, imm64; jmp rax (12 bytes)                      │
│  ├─ Slack space finder in hv.exe                                │
│  ├─ Proximity kernel pool allocation                            │
│  └─ Trampoline verification                                     │
│                                                                  │
│  RUNTIME_HIJACK_EXAMPLE.cpp                                     │
│  ├─ BasicRuntimeHijack() - Full hijack flow                     │
│  ├─ VersionDiagnostic() - Version detection test                │
│  ├─ TrampolineDiagnostic() - Trampoline test                    │
│  └─ PreFlightChecks() - System readiness checks                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ Hypercall Verification (Namespace: zerohvci::hypercall)         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  hypercall_verify.h (180+ lines)                                │
│  ├─ ExecuteHypercall() - CPUID-based hypercall wrapper          │
│  ├─ GenerateSessionKey() - RDTSC-based key generation           │
│  ├─ SetCommunicationKey() - VMCALL_SET_COMM_KEY bootstrap       │
│  ├─ VerifyHypercallWorks() - VMCALL_GET_CR3 test                │
│  └─ VerifyHypervisorActive() - Complete verification sequence   │
│                                                                  │
│  HYPERCALL_VERIFY_EXAMPLE.cpp                                   │
│  ├─ Phase 3.1 example: Full flow with verification              │
│  ├─ Minimal verification example                                │
│  └─ Manual step-by-step example                                 │
│                                                                  │
│  PHASE_3_1_HYPERCALL_VERIFICATION.md                            │
│  ├─ Architecture documentation                                  │
│  ├─ CPUID hypercall mechanism details                           │
│  ├─ Authentication system explanation                           │
│  ├─ Debugging guide                                             │
│  └─ Integration patterns                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ Documentation & Examples                                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  README.md (275 lines)                                          │
│  ├─ Architecture overview                                       │
│  ├─ Usage examples                                              │
│  ├─ Build requirements                                          │
│  ├─ Security considerations                                     │
│  └─ Compatibility matrix                                        │
│                                                                  │
│  INTEGRATION_EXAMPLE.cpp (~ lines)                              │
│  ├─ Example 1: Basic kernel memory access                       │
│  ├─ Example 2: Kernel pool allocation                           │
│  ├─ Example 3: ROP-based function calls                         │
│  ├─ Example 4: Ombra bootkit integration                        │
│  └─ Example 5: Cleanup procedures                               │
│                                                                  │
│  FILE_STRUCTURE.txt (this file)                                 │
│  └─ Visual directory map                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

Namespace Hierarchy
===================

zerohvci::
  ├─ Initialize()
  ├─ ReadKernelMemory()
  ├─ WriteKernelMemory()
  ├─ AllocateKernelPool()
  ├─ Cleanup()
  ├─ IsInitialized()
  ├─ GetSystemCr3()
  ├─ GetCurrentKThread()
  ├─ GetCurrentEProcess()
  │
  ├─ [Internal - exploit.h]
  │   ├─ ObtainKernelExploitCSC()
  │   ├─ ObtainKernelExploitKS()
  │   └─ GetKThreadPreviousModeOffset()
  │
  ├─ [Internal - utils.h]
  │   ├─ GetKernelObject()
  │   ├─ GetSystemInformation()
  │   ├─ LdrMapImage()
  │   ├─ LeakGadgetAddress()
  │   └─ ... (15+ utility functions)
  │
  ├─ kforge::
  │   ├─ Initialize()
  │   ├─ Cleanup()
  │   ├─ CallKernelFunctionViaAddress()
  │   ├─ CallKernelFunctionViaName<Ret, Args...>()
  │   ├─ ExAllocatePool()
  │   └─ smartNoRetCall<Args...>()
  │
  ├─ version::
  │   ├─ DetectWindowsVersion()
  │   ├─ GetKThreadPreviousModeOffset()
  │   ├─ GetKThreadOffsets(buildNumber)
  │   ├─ FindVmExitSignature(buildNumber, isIntel)
  │   ├─ RequiresIndirectContext(buildNumber)
  │   ├─ GetVersionName(buildNumber)
  │   └─ g_VersionInfo (global version state)
  │
  ├─ trampoline::
  │   ├─ TrampolineCode struct (12 bytes)
  │   ├─ TrampolineInfo struct
  │   ├─ IsWithinCallRange(from, to)
  │   ├─ CalculateCallRva(callRip, target)
  │   ├─ BuildTrampolineCode(tramp, target)
  │   ├─ FindSlackSpaceInModule(...)
  │   ├─ AllocateNearModule(moduleBase, size)
  │   ├─ AllocateTrampoline(...)
  │   └─ VerifyTrampoline(addr)
  │
  ├─ hyperv::
  │   ├─ RuntimeHijacker class
  │   │   ├─ Initialize()
  │   │   ├─ HijackHyperV(payload, size)
  │   │   ├─ IsIntel()
  │   │   ├─ GetHyperVInfo()
  │   │   ├─ GetPayloadBase()
  │   │   ├─ UsesTrampoline()
  │   │   ├─ GetTrampolineAddr()
  │   │   ├─ RequiresIndirectContext()
  │   │   └─ GetHookLen()
  │   └─ RUNTIME_OMBRA_T struct (extended)
  │
  └─ hypercall::
      ├─ ExecuteHypercall(code, param1, param2, key)
      ├─ GenerateSessionKey()
      ├─ SetCommunicationKey(key)
      ├─ VerifyHypercallWorks(outCr3, session_key)
      └─ VerifyHypervisorActive()

Compile-Time Dependencies
==========================

Windows SDK:
  - Windows.h
  - winternl.h
  - Psapi.h

Windows Driver Kit (WDK):
  - Ks.h
  - KsMedia.h

Link Libraries:
  - ntdll.lib
  - Psapi.lib
  - ksproxy.lib

Compiler Requirements:
  - C++17 or later (/std:c++17)
  - Exception handling (/EHsc)
  - MSVC 2019 or later

Global Variables (inline storage)
==================================

ntdefs.h:
  - NtReadVirtualMemory
  - NtWriteVirtualMemory
  - NtFsControlFile

utils.h:
  - g_KernelAddr
  - g_KernelImage

kforge.h:
  - g_bInitialized
  - g_dwKernelSize
  - g_dwKernelImageSize
  - g_ZwTerminateThread
  - g_RopAddr_1 through g_RopAddr_5

zerohvci.cpp (static):
  - g_Initialized
  - g_CurrentKThread
  - g_CurrentEProcess
  - g_SystemCr3

Integration with OmbraLoader
=============================

To use ZeroHVCI in OmbraLoader's main.cpp:

    #include "zerohvci/zerohvci.h"

    int main() {
        // Initialize exploit
        if (!zerohvci::Initialize()) {
            printf("[-] Exploit failed\n");
            return -1;
        }

        // Use kernel R/W primitives
        // ... your code here ...

        // Cleanup
        zerohvci::Cleanup();
        return 0;
    }

Build System Integration:

    1. Add zerohvci/*.cpp to OmbraLoader.vcxproj
    2. Add include path: $(ProjectDir)
    3. Link additional libraries: ksproxy.lib
    4. Ensure WDK headers are in include path

Notes
=====

- All functions are in zerohvci namespace (no global pollution)
- Inline storage prevents ODR violations
- Header-only design (except zerohvci.cpp)
- MSVC-specific (uses intrinsics and calling conventions)
- Requires Administrator privileges
- Single-use exploit (process must terminate after use)

